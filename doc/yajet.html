<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>YAJET &ndash; JavaScript Template Engine</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2010-05-30 10:45:08 CEST"/>
<meta name="author" content="Mihai Bazon"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color:lightblue; font-weight:normal }
  .target { }
  .timestamp { color: grey }
  .timestamp-kwd { color: CadetBlue }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="docstyle.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*/-->
</script>
</head><body>
<h1 class="title">YAJET &ndash; JavaScript Template Engine</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Yet Another JavaScript Emplate Tengine[1] </a></li>
<li><a href="#sec-2">2 What makes it different </a>
<ul>
<li><a href="#sec-2.1">2.1 Features </a></li>
</ul>
</li>
<li><a href="#sec-3">3 Usage </a>
<ul>
<li><a href="#sec-3.1">3.1 Template arguments </a></li>
<li><a href="#sec-3.2">3.2 Reader char </a></li>
</ul>
</li>
<li><a href="#sec-4">4 Syntax </a>
<ul>
<li><a href="#sec-4.1">4.1 Simple interpolation (the <code>$foo</code> construct) </a>
<ul>
<li><a href="#sec-4.1.1">4.1.1 Notes </a></li>
</ul>
</li>
<li><a href="#sec-4.2">4.2 JavaScript expressions (the <code>${exp}</code> construct) </a>
<ul>
<li><a href="#sec-4.2.1">4.2.1 Filters </a></li>
</ul>
</li>
<li><a href="#sec-4.3">4.3 Directives </a>
<ul>
<li><a href="#sec-4.3.1">4.3.1 <code>IF</code> / <code>WHEN</code> / <code>UNLESS</code>, <code>ELSE</code> / <code>ELSIF</code> &mdash; conditional execution </a></li>
<li><a href="#sec-4.3.2">4.3.2 <code>AIF</code> / <code>AWHEN</code> &mdash; like <code>IF</code> / <code>WHEN</code>, but store the condition in <code>$it</code> </a></li>
<li><a href="#sec-4.3.3">4.3.3 <code>REPEAT</code> &mdash; to repeat stuff </a></li>
<li><a href="#sec-4.3.4">4.3.4 <code>MAP</code> / <code>FOREACH</code> &mdash; iterate an array </a></li>
<li><a href="#sec-4.3.5">4.3.5 <code>MAPHASH</code> &mdash; iterate an object (hash) </a></li>
<li><a href="#sec-4.3.6">4.3.6 <code>CONTINUE</code> and <code>BREAK</code> &mdash; for loop control </a></li>
<li><a href="#sec-4.3.7">4.3.7 <code>LET</code> &mdash; define variables </a></li>
<li><a href="#sec-4.3.8">4.3.8 <code>WITH</code> &mdash; modify the scope chain </a></li>
<li><a href="#sec-4.3.9">4.3.9 <code>BLOCK</code> &mdash; define reusable template blocks </a></li>
<li><a href="#sec-4.3.10">4.3.10 <code>WRAP</code>, <code>CONTENT</code> &mdash; call a wrapper with an additional block of text </a></li>
<li><a href="#sec-4.3.11">4.3.11 <code>EXPORT</code> &mdash; define a BLOCK that can be used in another template </a></li>
<li><a href="#sec-4.3.12">4.3.12 <code>LITERAL</code> &mdash; include literal text </a></li>
<li><a href="#sec-4.3.13">4.3.13 <code>SYNTAX</code> &mdash; temporarily change the reader character </a></li>
<li><a href="#sec-4.3.14">4.3.14 Literal JavaScript with <code>$( ... )</code> </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-5">5 Correctness </a>
<ul>
<li><a href="#sec-5.1">5.1 Loop control </a></li>
<li><a href="#sec-5.2">5.2 The value of <code>this</code> </a></li>
</ul>
</li>
<li><a href="#sec-6">6 Custom directives </a>
<ul>
<li><a href="#sec-6.1">6.1 A more involved example &mdash; <code>SWITCH</code> </a></li>
</ul>
</li>
<li><a href="#sec-7">7 Known issues </a>
<ul>
<li><a href="#sec-7.1">7.1 Literal RegExp-s in JavaScript expressions </a></li>
<li><a href="#sec-7.2">7.2 Error reporting is less than ideal </a></li>
<li><a href="#sec-7.3">7.3 Whitespace handling </a></li>
</ul>
</li>
<li><a href="#sec-8">8 How to get help </a></li>
<li><a href="#sec-9">9 License </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1 Yet Another JavaScript Emplate Tengine<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup> </h2>
<div id="text-1">


<p>
A “template engine” is a tool able to transform some text into another, by
interpreting/replacing various patterns in the source text.  YAJET is such a
tool designed for client-side (JavaScript, in-browser) transformation.
</p>
<p>
YAJET is a compiler, in the sense that it transforms your template into
executable JavaScript code; after compiling a template you get a function
which you can call with data required to fill your template, and it returns
it rendered.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2 What makes it different </h2>
<div id="text-2">


<p>
I think that all template tools suck to some degree, and this has to
be because they are bringing together two (or more) languages.  The
syntax is always creepy.  YAJET is no exception from this fundamental
rule, but still I think it's better than others.  It has a nice lispy
syntax for directives, that feels much better than the sheer ugliness
that other template toolkits propose.  But it also strives to keep
simple things simple:
</p>
<ul>
<li>
<code>$foo</code> &mdash; insert variable foo
</li>
<li>
<code>$foo|html</code> &mdash; insert variable foo, HTML escaped
</li>
<li>
<code>$$</code> &mdash; insert a literal dollar sign
</li>
<li>
<code>${ a() + b() }</code> &mdash; insert sum of a() and b()
</li>
<li>
<code>${ a() + b() =&gt; html }</code> &mdash; insert sum of a() and b(), HTML escaped
</li>
<li>
<code>$(REPEAT (3 =&gt; i) &lt;li&gt;Item $i&lt;/li&gt; $)</code> &mdash; display 3 items

</li>
</ul>

<p>Rather than encouraging you to write pieces of literal JavaScript in
your templates<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup>, YAJET defines some high-level directives
that allow you to traverse lists, define blocks, conditionals and so
on with a cleaner syntax; and it translates them into running
JavaScript in a <a href="#sec-5">proper</a> way.  So you don't write, for example:
</p>



<pre class="src src-html">
&lt;<span style="color: #a020f0;">?js</span> for (var i = 0; i &lt; list.length; ++i) { ?&gt;
&lt;<span style="color: #a020f0;">?js</span>     var el = list[i] ?&gt;
     &lt;<span style="color: #0000ff;">li</span>&gt;#{el}&lt;/<span style="color: #0000ff;">li</span>&gt;
&lt;<span style="color: #a020f0;">?js</span> } ?&gt;
</pre>




<p>
(the example above is from <a href="http://www.kuwata-lab.com/tenjin/jstenjin-examples.html">Tenjin</a>).  In YAJET you write it like this:
</p>



<pre class="src src-html">
$(MAP (el =&gt; list)  &lt;<span style="color: #0000ff;">li</span>&gt;$el&lt;/<span style="color: #0000ff;">li</span>&gt;  $)
</pre>




<p>
Or if you like the Perl style, you can do<sup><a class="footref" name="fnr.3" href="#fn.3">3</a></sup>: <code>$(FOREACH (list) &lt;li&gt;$_&lt;/li&gt;$)</code>.
</p>
<p>
There was an explosion of “jQuery template engines” lately, generated
by jQuery's outstanding support for CSS selectors&mdash;people<sup><a class="footref" name="fnr.4" href="#fn.4">4</a></sup>
write &lt;div class="foo"&gt;&lt;/div&gt; to introduce a DIV containing the
variable <code>foo</code>.  I don't like this style.  YAJET is appropriate for
any kind of text templates&mdash;it was not designed specifically for
HTML, although that's mostly what I use it for.
</p>

</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1">2.1 Features </h3>
<div id="text-2.1">


<p>
Other than the boring variable interpolation, we have the following:
</p>
<ul>
<li>
simple filters a la <a href="http://template-toolkit.org/">Template::Toolkit</a> (i.e. <code>$foo|html</code> will HTML-escape
the value of foo).

</li>
<li>
conditionals (<code>IF</code> / <code>WHEN</code> / <code>UNLESS</code>, <code>ELSE</code>, <code>ELSIF</code>).

</li>
<li>
repetitive constructs (<code>REPEAT</code>).  They allow you to repeat a part
of the template a few times.

</li>
<li>
iterating arrays or hashes (<code>MAP</code> and <code>MAPHASH</code>) &ndash; <code>MAP</code> to
traverse a list and <code>MAPHASH</code> to iterate an object (hash table).

</li>
<li>
all loops can be controlled by <code>BREAK</code> or <code>CONTINUE</code>.

</li>
<li>
variable definition (<code>LET</code>) and dynamic scope manipulation (<code>WITH</code>).

</li>
<li>
components (<code>BLOCK</code> and <code>EXPORT</code>).  Useful to declare blocks that
can be called, multiple times, as a function.  <code>EXPORT</code> declares
functions that can be called from a different template.

</li>
<li>
components can be called as <code>WRAP</code>-pers.  They receive some content
and are able to output something before and after it.  The content
is processed as template.

</li>
<li>
various types of comments.

</li>
<li>
the ability to include literal text, or to temporarily modify the
reader character.

</li>
<li>
you can easily define custom directives.

</li>
<li>
<a href="#sec-5">Correctness</a>.

</li>
<li>
it compiles the template into a runnable JavaScript function which
is blazing fast.  Compilation speed is quite good too, but of
course, you only need to compile a template <i>once</i>.

</li>
<li>
the code is way shorter than the documentation<sup><a class="footref" name="fnr.5" href="#fn.5">5</a></sup> (10K
minified, 4.5K gzipped) and it's completely self-contained (no
library requirements, and it should not clash with any library).  I
think it's quite small for the number of features.

</li>
<li>
it's browser agnostic.  In fact, it works with standalone JavaScript engines too (such as <a href="http://code.google.com/p/v8/">Google's V8</a>
or <a href="http://www.mozilla.org/rhino/">Rhino</a>).  I started a test suite based on Rhino.


</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3 Usage </h2>
<div id="text-3">


<p>
You need to load <a href="../js/yajet.js">yajet.js</a>, and to create an instance like this:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">yajet</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">YAJET</span>({
    reader_char : <span style="color: #bc8f8f;">"$"</span>,
    with_scope  : <span style="color: #5f9ea0;">false</span>,
    filters     : {
        <span style="color: #0000ff;">foo</span>: <span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">val</span>) { <span style="color: #b22222;">/*</span><span style="color: #b22222;">...*/</span> },
        <span style="color: #0000ff;">bar</span>: <span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">val</span>) { <span style="color: #b22222;">/*</span><span style="color: #b22222;">...*/</span> }
    }
});
</pre>




<p>
All arguments are optional.  Then to compile a template, you do this:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">func</span> = yajet.compile(<span style="color: #bc8f8f;">"You said: $this.foo $this.bar"</span>);
</pre>




<p>
and to execute it:
</p>



<pre class="src src-espresso">
alert( func({ foo: <span style="color: #bc8f8f;">"hello"</span>, bar: <span style="color: #bc8f8f;">"world!"</span> }) );
</pre>





</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1">3.1 Template arguments </h3>
<div id="text-3.1">


<p>
The function <b>returned</b> by “yajet.compile” receives one argument, and that
argument is available in your templates via the JavaScript <code>this</code> keyword.
This is the default behavior, because I think it's the best one in general,
but if you don't like to use the <code>this.</code> prefix to access the members you
can pass <code>with_scope: true</code> in the constructor.  It wraps the generated
function in a <code>with(this) { ... }</code> block, so the above would become:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">yajet</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">YAJET</span>({ with_scope: <span style="color: #5f9ea0;">true</span> });
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">func</span> = yajet.compile(<span style="color: #bc8f8f;">"You said: $foo $bar"</span>);
<span style="color: #b22222;">// </span><span style="color: #b22222;">and call it the same way:
</span>alert( func({ foo: <span style="color: #bc8f8f;">"hello"</span>, bar: <span style="color: #bc8f8f;">"world!"</span> }) );
</pre>




<p>
It's more convenient, but it's slower.  How much slower depends on how
big is your template and how many variables there are.  If you want a
comparison for a large number of iterations with and without the
<code>with</code> statement, <a href="../test/with.html">see this file</a> (Firebug is required for timing the
operations; watch the Firebug console; it also works in Chrome with
its JavaScript console; Chrome is even slower than Firefox for the
<code>with</code> case).
</p>
</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2">3.2 Reader char </h3>
<div id="text-3.2">


<p>
Template syntax is triggered by a single special character called the
“reader char”.  By default this character is <code>$</code>, but you can use
anything else by passing the <code>reader_char</code> constructor argument.  I
personally would prefer to use some Unicode character, for instance:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">yajet</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">YAJET</span>({ reader_char: <span style="color: #bc8f8f;">"&#8226;"</span> });
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">tmpl</span> = yajet.compile(<span style="color: #bc8f8f;">"You said &#8226;this.foo &#8226;this.bar"</span>);
</pre>





</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">4 Syntax </h2>
<div id="text-4">


<p>
YAJET parses the template as text, leaving it unchanged, until it encounters
the “reader char”.  What follows in this document will assume that $ is the
reader character (the default).  A few types of constructs are recognized:
</p>
<ul>
<li>
<code>$$</code> &mdash; inserts a literal $ character.

</li>
<li>
<code>$-</code> &mdash; skips the following whitespace.

</li>
<li>
<code>$#</code> &mdash; comment (ignore) until the end of the line.

</li>
<li>
<code>$foo</code>, <code>$foo.bar</code> &mdash; inserts the value of the variable foo, foo.bar etc.

</li>
<li>
<code>${ foo.bar.baz() }</code> &mdash; evaluates the given JavaScript expression and
inserts the return value, if any.

</li>
<li>
<code>$(DIRECTIVE ... $)</code> &mdash; processes the contents according to some
rules which are particular for <code>DIRECTIVE</code>.

</li>
<li>
<code>$( ... )</code> &mdash; inserts literal JavaScript code (must not be ill-formed!).

</li>
</ul>

</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1">4.1 Simple interpolation (the <code>$foo</code> construct) </h3>
<div id="text-4.1">


<p>
To insert a variable you can say <code>$foo</code>, <code>$foo.bar</code>, etc.  This case
is quite simple.  The parser will stop at a character which isn't a
letter, a digit, an underscore, a dot or a pipe.  The pipe is for
conveniently filtering the value: <code>$foo|html</code> will HTML-escape the
value of foo before inserting it into the output.
</p>
<p>
Note that when the dot or pipe is followed by a non-word character,
then they are not considered part of the token and are left as is.
Thus you can safely say <code>“Your name is |$user.name| and score is $score.”</code>
</p>
<p>
Filters are functions that take one argument and should return the
modified value.  You can easily define your own filters (more on this
later).  Filters can be combined, for example: <code>$foo|upcase|html</code> will
first make foo uppercase, then apply the html filter to the upcased
string.
</p>

</div>

<div id="outline-container-4.1.1" class="outline-4">
<h4 id="sec-4.1.1">4.1.1 Notes </h4>
<div id="text-4.1.1">


<ul>
<li>
In order to insert literally the reader character in the template
output you have to put it twice, i.e. <code>$$</code>.

</li>
<li>
Because the pipe character is used for filtering, you cannot write
the following: <code>$foo|bar</code> to get the value of “foo”, followed by a
literal pipe, followed by the text "bar".  Instead you should write
it like this: <code>${foo}|bar</code> (the next session discusses the <code>${foo}</code>
construct).

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2">4.2 JavaScript expressions (the <code>${exp}</code> construct) </h3>
<div id="text-4.2">


<p>
This is similar to “simple interpolation”, in that the value of the
expression gets inserted into the output.  For example <code>${a+b}</code> will
insert the sum of a and b.  The scanner is smart enough to read
arbitrarily complex expressions, provided that they are properly
balanced (you need to be <b>careful about literal RegExp-s</b> for now;
more on this in <a href="#sec-7">Known issues</a>).
</p>
<p>
So, an example of a perfectly valid call is:
</p>



<pre class="src src-espresso">
${
   <span style="color: #b22222;">// </span><span style="color: #b22222;">Comments are ignored, so they can contain the closing bracket: }
</span>   (<span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">arg</span>){
     <span style="color: #b22222;">// </span><span style="color: #b22222;">you can use the brackets in your expression too,
</span>     <span style="color: #b22222;">// </span><span style="color: #b22222;">because the scanner won't stop until it's properly balanced
</span>     <span style="color: #a020f0;">return</span> arg.a + arg.b + arg.text;
   })({
     &lt;!-- as a bonus, you can have HTML comments too --&gt;
     a: 5,
     b: 10,
     text: <span style="color: #bc8f8f;">"(foo}"</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">strings too
</span>   })
}
</pre>




<p>
The expression is evaluated at runtime and its value is inserted into
the template output only if it's not null.  The above would output
"<code>15(foo}</code>".
</p>

</div>

<div id="outline-container-4.2.1" class="outline-4">
<h4 id="sec-4.2.1">4.2.1 Filters </h4>
<div id="text-4.2.1">


<p>
As already noted, the <code>$foo</code> construct allows filtering the value through
some function using a convenient syntax like <code>$foo|html</code>.  At the time of
this writing the filters available by default are:
</p>
<ul>
<li>
<code>html</code> &mdash; encodes HTML special characters
</li>
<li>
<code>upcase</code> &mdash; converts the string to uppercase
</li>
<li>
<code>downcase</code> &mdash; lowercase the string
</li>
<li>
<code>trim</code> &mdash; removes leading and trailing whitespace
</li>
<li>
<code>plural</code> &mdash; useful for returning "no elements", "one element", "3 elements" depending on a numeric value.

</li>
</ul>

<p>It's easy to define custom filters when you construct the YAJET object:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">yajet</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">YAJET</span>({
    filters: {
        <span style="color: #0000ff;">md5</span>: <span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">value</span>) {
            <span style="color: #a020f0;">return</span> md5_hex_of(value); <span style="color: #b22222;">// </span><span style="color: #b22222;">return the modified value
</span>        }
    }
});
</pre>




<p>
&hellip; and in your template: <code>$password|md5</code>.
</p>
<p>
There is also a syntax that allows for filters within the <code>${exp}</code>
construct.  But since we parse valid JavaScript code, and since the pipe is
a valid JavaScript character (“bitwise or”), we have to use something
different.  The idea was, thus, that such expressions will be parsed as a
list; the first element of the list is the expression itself, and any
additional elements are filters.  For example:
</p>



<pre class="src src-espresso">
${ <span style="color: #5f9ea0;">this</span>.getLabel(), upcase, html }
</pre>




<p>
will convert into something like this:
</p>



<pre class="src src-espresso">
output_string(
  apply_html_filter(
    apply_upcase_filter(
      <span style="color: #5f9ea0;">this</span>.getLabel()
    )
  )
)
</pre>




<p>
Since the comma doesn't look very nice for this particular case, the “list
reader” also allows a few aliases.  Syntactic sugar, baby!  You can also
use:
</p>
<ul>
<li>
<code>“=&gt;”</code>
</li>
<li>
<code>“,”</code>
</li>
<li>
<code>“..”</code>
</li>
<li>
<code>“;”</code>

</li>
</ul>

<p>So the above example can also be written like this:
</p>



<pre class="src src-espresso">
${ <span style="color: #5f9ea0;">this</span>.getLabel() =&gt; upcase =&gt; html }
${ <span style="color: #5f9ea0;">this</span>.getLabel() =&gt; upcase, html }
${ <span style="color: #5f9ea0;">this</span>.getLabel() .. upcase; html }
</pre>




<p>
These special separators only work for the “list reader”, which is used in
the <code>${exp}</code>-like constructs (and several others).  Also, note that filters
are only interpreted in the top-level elements of this list, so for instance
the following won't apply the "html" filter to “foo”: <code>${ something(foo, html) }</code>.  It will just call, instead, the function <code>something</code>, passing the
variables <code>foo</code> and <code>html</code>, which is expected behavior.
</p>
<p>
When used in the <code>${exp}</code> construct, filters can receive additional
arguments.  For example, assuming you have some date formatting library, you
can easily define a filter that formats a Date object according to the
arguments:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">yajet</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">YAJET</span>({
    filters: {
        <span style="color: #0000ff;">format_date</span>: <span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">date</span>, <span style="color: #b8860b;">format</span>) {
            <span style="color: #b22222;">// </span><span style="color: #b22222;">... now return the *date* formatted according to *format*
</span>        }
    }
});
</pre>




<p>
and in the template:
</p>



<pre class="example">
“Today is: ${ new Date() =&gt; format_date("YYYY-MM-DD") }”
</pre>




<p>
The first argument of your filter is always the value from the template (in
the above case, the Date object created with <code>new Date()</code>), and the other
arguments are passed following the filter name ("YYYY-MM-DD").
</p>

<hr/>

<p>
You would use “plural” like this:
</p>



<pre class="example">
1. We got ${ count =&gt; plural("no items", "one item", "two items", "# items") }
2. We got ${ count =&gt; plural([ "no items", "one item", "two items", "# items" ]) }
3. We got ${ count =&gt; plural("no items|one item|two items|# items") }
</pre>




<p>
Besides the implicit argument (<code>count</code>) plural accepts multiple
arguments (case 1 above), or a single array argument (case 2) or a
string (case 3) that specifies the formats separated by a pipe
character.  In all cases, the arguments specify how to display the
numeric value.  If it's zero, it selects the first argument; if it's
one, it selects the second, and so on.  If it's bigger than the number
of arguments, it selects the last one.  <code>#</code> is replaced with the
number.  So the above displays "We got no items" when count is zero,
"We got one item" when count is 1, "We got two items" when count is 2
and "We got # items" when count is bigger (where # is replaced with the value of count).
</p>
</div>
</div>

</div>

<div id="outline-container-4.3" class="outline-3">
<h3 id="sec-4.3">4.3 Directives </h3>
<div id="text-4.3">


<p>
So far we are able to introduce arbitrary JavaScript variables and
expressions in the template.  However that's hardly enough.  First off, the
expressions must be well-formed, so there is no way to start a JavaScript
block somewhere and end it some place else.  The following is invalid for
obvious reasons:
</p>



<pre class="src src-html">
${ if (link != null) { }
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"$link|html"</span>&gt;$link&lt;/<span style="color: #0000ff;">a</span>&gt;
${ } }
</pre>




<p>
I emphasize that the lack of support for partial expressions is a
<i>feature</i>, not a limitation.  This will never be “fixed”.  To support
constructs like the above but without encouraging bad style or awful
syntax, we have a few special processing directives.  Let's call these
the <code>$(BAR ... $)</code> construct.  To start with, here is how you would
write the above code:
</p>



<pre class="src src-html">
$(IF (link != null)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"$link|html"</span>&gt;$link&lt;/<span style="color: #0000ff;">a</span>&gt;
$)
</pre>




<p>
All blocks end with a closing paren; no need for “{/IF}”, “.IF”,
“END”, “&lt;? } ?&gt;” etc.  This has an incredible advantage<sup><a class="footref" name="fnr.6" href="#fn.6">6</a></sup>:
if your editor can properly match parens, you can immediately see
where a block starts or ends by just moving the caret to the
ending/opening paren.
</p>
<p>
Note that the processing instructions are not case-sensitive.  I prefer to
use UPPERCASE for them so that they stand out visually.
</p>
<p>
The <code>$(BAR ... $)</code> construct has the following properties:
</p>
<ul>
<li>
it starts with <code>$(</code> (so it's a normal paren, not a bracket)
</li>
<li>
it continues with a special instruction (again, I prefer uppercase for
this but it's not required)
</li>
<li>
depending on the instruction, certain arguments may follow
</li>
<li>
it <i>usually</i> ends with <code>$)</code>
</li>
<li>
it may contain a <i>block of text</i> between the arguments and the <code>$)</code>
terminator

</li>
</ul>

<p>The <i>block of text</i> is parsed normally, so it's interpreted as plain text
until <code>$</code> (the reader char) is encountered, then what follows the reader
char is processed by the rules I described in this document.
</p>
<p>
Following I will describe the directives available at this time.  I think
the set of them is quite comprehensive and allows you to express any kind of
template in a simple and consistent manner.
</p>

</div>

<div id="outline-container-4.3.1" class="outline-4">
<h4 id="sec-4.3.1">4.3.1 <code>IF</code> / <code>WHEN</code> / <code>UNLESS</code>, <code>ELSE</code> / <code>ELSIF</code> &mdash; conditional execution </h4>
<div id="text-4.3.1">


<p>
<code>IF</code> and <code>WHEN</code> are synonyms, while <code>UNLESS</code> is the antonym.  <code>WHEN</code> seems more
appropriate for cases where you don't have an <code>ELSE</code> clause.  They support one
argument which must be a condition enclosed in parens.  Examples:
</p>



<pre class="src src-html">
$(WHEN (user_id == null)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"..."</span>&gt;Please login&lt;/<span style="color: #0000ff;">a</span>&gt; $)

$(UNLESS (user_id != null)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"..."</span>&gt;Please login&lt;/<span style="color: #0000ff;">a</span>&gt; $)

$(IF (a &lt; b)
  &lt;<span style="color: #0000ff;">p</span>&gt;A is smaller&lt;/<span style="color: #0000ff;">p</span>&gt;
$(ELSIF (a &gt; b))
  &lt;<span style="color: #0000ff;">p</span>&gt;B is smaller&lt;/<span style="color: #0000ff;">p</span>&gt;
$(ELSE)
  &lt;<span style="color: #0000ff;">p</span>&gt;A and B are equal&lt;/<span style="color: #0000ff;">p</span>&gt; $)
</pre>




<p>
Note that you can use <code>ELSE</code> or <code>ELSIF</code> inside <code>UNLESS</code> or <code>WHEN</code> blocks
too, although I would not advise to use this style:
</p>



<pre class="example">
$(UNLESS (a == b)
  they are different
$(ELSE)
  they are equal $)
</pre>




<p>
You should also note that <code>ELSE</code> and <code>ELSIF</code> are not actually parsed like
other instructions.  They don't take a block of text, and thus they don't
need to end with <code>$)</code>.  Whether to do it this way was hard to decide, but
since <code>ELSE</code> and <code>ELSIF</code> normally <i>continue</i> an IF block, instead of ending
it, it seems to make sense this way.  The same applies to <code>$(BREAK)</code> and
<code>$(CONTINUE)</code> directives.
</p>
</div>

</div>

<div id="outline-container-4.3.2" class="outline-4">
<h4 id="sec-4.3.2">4.3.2 <code>AIF</code> / <code>AWHEN</code> &mdash; like <code>IF</code> / <code>WHEN</code>, but store the condition in <code>$it</code> </h4>
<div id="text-4.3.2">


<p>
These two come from the <a href="http://common-lisp.net/project/anaphora/">anaphoric macro collection from Hell</a> and I
find them quite useful for cases where the block inside the <code>IF</code> is
not very big.  They help with the following case:
</p>



<pre class="example">
$(LET ((foo =&gt; this.looongComputation()))
  $(WHEN (foo)
    ... do something with $foo
  $)
$)
</pre>




<p>
The two <a href="http://en.wikipedia.org/wiki/Anaphora_(linguistics)">anaphoric</a> macros (which are synonyms) allow you to avoid the
boilerplate:
</p>



<pre class="example">
$(AWHEN (this.looongComputation())
  .. do something with $it
$)
</pre>




<p>
The variable <code>$it</code> is created by the macro and takes the value of the
condition, and the text block is executed only if<sup><a class="footref" name="fnr.7" href="#fn.7">7</a></sup>:
</p>
<ul>
<li>
<code>$it</code> is not <code>null</code> and not <code>undefined</code>
</li>
<li>
<code>$it</code> is not <code>false</code> <sup><a class="footref" name="fnr.8" href="#fn.8">8</a></sup>
</li>
<li>
<code>$it</code> is not an empty array
</li>
<li>
<code>$it</code> is not an empty string

</li>
</ul>

<p>It expands to this code:
</p>



<pre class="src src-espresso">
(<span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">it</span>){
  <span style="color: #a020f0;">if</span> (it != <span style="color: #5f9ea0;">null</span> &amp;&amp; it !== <span style="color: #5f9ea0;">false</span> &amp;&amp; !(it <span style="color: #a020f0;">instanceof</span> <span style="color: #228b22;">Array</span> &amp;&amp; it.length == 0) &amp;&amp; !(it === <span style="color: #bc8f8f;">""</span>)) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">splice the block of code here
</span>  }
}).call(<span style="color: #5f9ea0;">this</span>, <span style="color: #5f9ea0;">this</span>.looongComputation());
</pre>




<p>
OK, now that you agree that this is useful, but are depressed by the
sheer lack of inspiration in picking the name <code>it</code>, let me show you
that you can actually name the variable:
</p>



<pre class="src src-html">
$(AWHEN (this.looongComputation() =&gt; that)
  <span style="color: #b22222;">&lt;!-- </span><span style="color: #b22222;">no more $it </span><span style="color: #b22222;">--&gt;</span>
  .. do something with $that
$)
</pre>




<p>
Also, for cases when you are unhappy with the default falsity rules,
you can state the full condition as well:
</p>



<pre class="example">
$(AIF (this.looongComputation() =&gt; foo, foo &gt; 5)
  $foo is now this.looongComputation() but this is displayed
  only if it's greater than 5.
$(ELSE)
  And you can still use $foo here.
$)
</pre>




</div>

</div>

<div id="outline-container-4.3.3" class="outline-4">
<h4 id="sec-4.3.3">4.3.3 <code>REPEAT</code> &mdash; to repeat stuff </h4>
<div id="text-4.3.3">


<p>
To repeat a part of the template you can use <code>REPEAT</code>.  For example,
the following outputs “foo” 3 times: <code>$(REPEAT (3) foo $)</code>.  In
various cases you might need to know the current iteration too, so you
can pass a variable name for it:
</p>



<pre class="example">
$(REPEAT (5, i)
  Item $i $)
</pre>




<p>
The variable <code>i</code> takes values from 1 to 5 (inclusively) and the output will
be “Item 1 Item 2 ” etc.  In some cases you might want to specify an
interval (so that you start from something else than 1), so the following is
allowed:
</p>



<pre class="src src-html">
$(REPEAT (5 .. 10 =&gt; i)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"/page$i"</span>&gt;Page $i&lt;/<span style="color: #0000ff;">a</span>&gt; $)
</pre>




<p>
Note that the arguments are parsed using the “list reader”, so you can
use syntactic sugar to separate them (although a simple comma would
do).
</p>
</div>

</div>

<div id="outline-container-4.3.4" class="outline-4">
<h4 id="sec-4.3.4">4.3.4 <code>MAP</code> / <code>FOREACH</code> &mdash; iterate an array </h4>
<div id="text-4.3.4">


<p>
Again, <code>MAP</code> and <code>FOREACH</code> are synonyms.  You can use them to do something
for each element of an array.  For example the following outputs links
contained in an array:
</p>



<pre class="src src-html">
$(MAP (link =&gt; links)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"$link.address|html"</span>
     <span style="color: #b8860b;">title</span>=<span style="color: #bc8f8f;">"$link.tooltip|html"</span>&gt;$link.text|html&lt;/<span style="color: #0000ff;">a</span>&gt; $)
</pre>




<p>
That's assuming that <code>links</code> is an array of objects, each containing
<code>address</code>, <code>tooltip</code> and <code>text</code>.  You could of course use a literal
object:
</p>



<pre class="src src-html">
$(MAP (link =&gt; [ { address : <span style="color: #bc8f8f;">"http://www.google.com/"</span>,
                   tooltip : <span style="color: #bc8f8f;">"Search engine"</span>,
                   text    : <span style="color: #bc8f8f;">"Google"</span> },

                 { address : <span style="color: #bc8f8f;">"http://www.ymacs.org/"</span>,
                   tooltip : <span style="color: #bc8f8f;">"AJAX code editor"</span>,
                   text    : <span style="color: #bc8f8f;">"Ymacs"</span> }
               ])
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"$link.address|html"</span>
     <span style="color: #b8860b;">title</span>=<span style="color: #bc8f8f;">"$link.tooltip|html"</span>&gt;$link.text|html&lt;/<span style="color: #0000ff;">a</span>&gt; $)
</pre>




<p>
Sometimes you also need to know the current step of the iteration.  For
example if you want to output some links that are separated with a pipe, you
need to know not to output the pipe before the first, or after the last
link.  We could write it like this:
</p>



<pre class="src src-html">
$(MAP (i, link =&gt; links)
  $(WHEN (i &gt; 0) | $)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>="$link.address|html"
     <span style="color: #b8860b;">title</span>="$link.tooltip|html"&gt;$link.text|html&lt;/<span style="color: #0000ff;">a</span>&gt; $)
</pre>




<p>
or
</p>



<pre class="src src-html">
$(MAP (i, link =&gt; links)
  ${ i &gt; 0 ? "|" : "" }
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>="$link.address|html"
     <span style="color: #b8860b;">title</span>="$link.tooltip|html"&gt;$link.text|html&lt;/<span style="color: #0000ff;">a</span>&gt; $)
</pre>




<p>
A special case of <code>MAP</code> / <code>FOREACH</code> allows you to pass only the array, and
no key or index variables.  In this case the special variable <code>$_</code> (which I
will call the Perlism) gets assigned to the current element, and <i>more</i>, the
loop body is lexically scoped to each element using a JavaScript <code>with</code>
block (I know, your mom told you not to play the <code>with</code> statement, but mine
didn't<sup><a class="footref" name="fnr.9" href="#fn.9">9</a></sup> :-p).
</p>
<p>
So using this style the first example would become:
</p>



<pre class="src src-html">
$(MAP (links)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"$address|html"</span> <span style="color: #b8860b;">title</span>=<span style="color: #bc8f8f;">"$tooltip|html"</span>&gt;$text|html&lt;/<span style="color: #0000ff;">a</span>&gt; $)
</pre>




<p>
<code>address</code>, <code>tooltip</code> and <code>text</code> access the specific property of each
element.
</p>
<p>
Just a last example showing the Perlism:
</p>



<pre class="src src-html">
$(FOREACH ([ <span style="color: #bc8f8f;">"foo"</span>, <span style="color: #bc8f8f;">"bar"</span>, <span style="color: #bc8f8f;">"baz"</span> ]) &lt;<span style="color: #0000ff;">b</span>&gt;<span style="font-weight: bold;">$_</span>&lt;/<span style="color: #0000ff;">b</span>&gt; $)
</pre>




<p>
will output “&lt;b&gt;foo&lt;/b&gt; &lt;b&gt;bar&lt;/b&gt; &lt;b&gt;baz&lt;/b&gt;”.  The <code>$_</code> variable is
bound to each element.  Note that because YAJET is doing <a href="#sec-5">The Right Thing</a>, the following will work as expected:
</p>



<pre class="example">
$(MAP ([ "foo", "bar", "baz" ])
  $(MAP ([ 1, 2, 3 ])
    inside: $_ $)
  outside: $_ $)
</pre>




<p>
When “inside”, <code>$_</code> will take the values from 1 to 3; “outside” it
will take "foo", "bar" then "baz".
</p>
</div>

</div>

<div id="outline-container-4.3.5" class="outline-4">
<h4 id="sec-4.3.5">4.3.5 <code>MAPHASH</code> &mdash; iterate an object (hash) </h4>
<div id="text-4.3.5">


<p>
<code>MAPHASH</code> is <code>MAP</code>'s analogue for hashes.  It iterates over all properties
of an object, binding a variable for the key and another for the value.  You
must specify names for these variables.  Example, assuming that <code>users</code> is a
hash that maps user IDs to some user objects (each of them having a
<code>getName()</code> method):
</p>



<pre class="src src-html">
$(MAPHASH (uid, obj =&gt; users)
  User &lt;<span style="color: #0000ff;">b</span>&gt;<span style="font-weight: bold;">$uid</span>&lt;/<span style="color: #0000ff;">b</span>&gt; has name &lt;<span style="color: #0000ff;">b</span>&gt;<span style="font-weight: bold;">${ obj.getName() }</span>&lt;/<span style="color: #0000ff;">b</span>&gt;&lt;<span style="color: #0000ff;">br</span> /&gt; $)
</pre>




</div>

</div>

<div id="outline-container-4.3.6" class="outline-4">
<h4 id="sec-4.3.6">4.3.6 <code>CONTINUE</code> and <code>BREAK</code> &mdash; for loop control </h4>
<div id="text-4.3.6">


<p>
These don't take any arguments, and also don't take a block of text,
so the expected syntax is <code>$(CONTINUE)</code> and <code>$(BREAK)</code>.  They can
appear in the text block of some looping construct, be it <code>REPEAT</code>,
<code>MAP</code>, <code>FOREACH</code> or <code>MAPHASH</code>, and they do the same as their
JavaScript counterparts, that is: <code>CONTINUE</code> will go to the next
iteration, skipping any code between it and the end of the loop, and
<code>BREAK</code> will immediately end the loop.
</p>
<p>
I'm giving an example just to illustrate the syntax:
</p>



<pre class="example">
$(REPEAT (10 =&gt; i)
  $(WHEN (i &gt; 5) $(BREAK) $)
  $i
$)
</pre>




<p>
The above will print numbers from 1 to 5.
</p>
</div>

</div>

<div id="outline-container-4.3.7" class="outline-4">
<h4 id="sec-4.3.7">4.3.7 <code>LET</code> &mdash; define variables </h4>
<div id="text-4.3.7">


<p>
You can define new variables with <code>LET</code>.  It introduces a new lexical
scope, so the variables that you define are only available in its
block of text.  If variables with the same name already exist, they
are shadowed while the <code>LET</code> block is in effect.  After the <code>LET</code>
block ends, previous bindings come back to life.
</p>



<pre class="example">
$(LET ((a =&gt; 10) (b =&gt; 20))
  $a + $b = ${ a + b }
$)
</pre>




<p>
Since <code>LET</code> takes a block of text, it ends with the normal block terminator
<code>$)</code>.  Here's an example to demonstrate scope:
</p>



<pre class="src src-espresso">
$( <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">x</span> = <span style="color: #bc8f8f;">"outside"</span> <span style="color: #b22222;">/* </span><span style="color: #b22222;">literal JS block, described later */</span> )
$(LET ((x =&gt; 10))
  $x is 10
  $(LET ((x =&gt; 20))
    $x is 20
  $)
  $x is back 10
$)
$x is <span style="color: #bc8f8f;">"outside"</span>
</pre>




<p>
<code>LET</code> operates by introducing an anonymous function, so it's
compatible with all browsers.  JavaScript 1.7 introduced a <code>let</code>
statement for declaring block-scoped variables, and it's supported by
Firefox, but unfortunately no other browser has it at the
moment<sup><a class="footref" name="fnr.10" href="#fn.10">10</a></sup>.
</p>
</div>

</div>

<div id="outline-container-4.3.8" class="outline-4">
<h4 id="sec-4.3.8">4.3.8 <code>WITH</code> &mdash; modify the scope chain </h4>
<div id="text-4.3.8">


<p>
When you have an object that has properties you need to access, you can use
a <code>WITH</code> block to make for a more convenient syntax, so instead of saying
<code>$object.foo</code> you would be able to say only <code>$foo</code>.  Assuming that <code>link</code>
contains <code>address</code>, <code>tooltip</code> and <code>text</code>, the following two are equivalent:
</p>



<pre class="src src-html">
&lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"$link.address|html"</span> <span style="color: #b8860b;">title</span>=<span style="color: #bc8f8f;">"$link.tooltip|html"</span>&gt;$link.text|html&lt;/<span style="color: #0000ff;">a</span>&gt;

$(WITH (link)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"$address|html"</span> <span style="color: #b8860b;">title</span>=<span style="color: #bc8f8f;">"$tooltip|html"</span>&gt;$text|html&lt;/<span style="color: #0000ff;">a</span>&gt; $)
</pre>




<p>
<code>WITH</code> can be used with literal objects as well:
</p>



<pre class="example">
$(WITH ({ foo: 10, bar: 20 })
  $foo + $bar = ${ foo + bar }
$)
</pre>




<p>
thus emulating a <code>LET</code> block, but it's less efficient because it uses the
<a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Statements/with">JavaScript with statement</a>.
</p>
</div>

</div>

<div id="outline-container-4.3.9" class="outline-4">
<h4 id="sec-4.3.9">4.3.9 <code>BLOCK</code> &mdash; define reusable template blocks </h4>
<div id="text-4.3.9">


<p>
A <code>BLOCK</code> doesn't immediately print anything into the template output;
instead it defines a function that returns its processed block of
text.
</p>
<p>
The syntax is straightforward.  It expects a name for the function,
followed by a list of arguments in parens (if there are no arguments,
put <code>()</code> like you do for a plain JavaScript function).  Then continue
with the block of text that the function should expand into:
</p>



<pre class="src src-html">
$(BLOCK display_link(link)
  &lt;<span style="color: #0000ff;">a</span> <span style="color: #b8860b;">href</span>=<span style="color: #bc8f8f;">"$link.address|html"</span> <span style="color: #b8860b;">title</span>=<span style="color: #bc8f8f;">"$link.title|html"</span>&gt;$link.text|html&lt;/<span style="color: #0000ff;">a</span>&gt;
$)

<span style="color: #b22222;">&lt;!-- </span><span style="color: #b22222;">call it literally </span><span style="color: #b22222;">--&gt;</span>
${ display_link({ address: <span style="color: #bc8f8f;">"/"</span>, title: <span style="color: #bc8f8f;">"Home page"</span>, text: <span style="color: #bc8f8f;">"Home"</span> }) }

<span style="color: #b22222;">&lt;!-- </span><span style="color: #b22222;">or call it for an object </span><span style="color: #b22222;">--&gt;</span>
$(FOREACH (i =&gt; links)
  ${ display_link(i) }
$)
</pre>




<p>
Note that the call to <code>display_link</code> is inside a <code>${...}</code> block, so
that the returned value gets inserted into the output.
</p>
<p>
Combining <code>BLOCK</code> and <code>LET</code> or <code>WITH</code> we can define closures:
</p>



<pre class="src src-html">
$(WITH ({ value: 0 })
  $(BLOCK counter()
    &lt;<span style="color: #0000ff;">p</span>&gt;Counter is ${ ++value }&lt;/<span style="color: #0000ff;">p</span>&gt; $) $)

${ counter() } -- now it's 1
${ counter() } -- now it's 2
${ counter() } -- now it's 3
</pre>




<p>
Doing the above with <code>LET</code> is a bit more tricky because <code>LET</code> creates its
own environment, so the <code>BLOCK</code> that you define within it is actually local
to the <code>LET</code> block.  The following won't work:
</p>



<pre class="src src-html">
$(LET ((value =&gt; 0))
  $(BLOCK counter()
    &lt;<span style="color: #0000ff;">p</span>&gt;Counter is ${ ++value }&lt;/<span style="color: #0000ff;">p</span>&gt; $) $)

${ counter() } -- error, counter is not defined!
</pre>




<p>
It's easy to see why if you see the code that gets generated for the above.
It looks like the following:
</p>



<pre class="src src-espresso">
(<span style="color: #a020f0;">function</span>(){
    <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">value</span> = 0;
    <span style="color: #a020f0;">function</span> <span style="color: #0000ff;">counter</span>() {
        output(<span style="color: #bc8f8f;">"Counter is "</span> + (++value));
    };
})();

output( counter() ); <span style="color: #b22222;">// </span><span style="color: #b22222;">but there's no free lunch
</span></pre>




<p>
To do this with a <code>LET</code> block we would have to export the function; we can
use an outside variable for that:
</p>



<pre class="src src-html">
$( var counter )
$(LET ((value =&gt; 0))
  $( counter = _counter <span style="color: #b22222;">&lt;!-- </span><span style="color: #b22222;">export it </span><span style="color: #b22222;">--&gt;</span> )
  $(BLOCK _counter()
    &lt;<span style="color: #0000ff;">p</span>&gt;Counter is ${ ++value }&lt;/<span style="color: #0000ff;">p</span>&gt; $) $)

${ counter() } -- now it works.
</pre>




</div>

</div>

<div id="outline-container-4.3.10" class="outline-4">
<h4 id="sec-4.3.10"><a name="WRAP" id="WRAP"></a>4.3.10 <code>WRAP</code>, <code>CONTENT</code> &mdash; call a wrapper with an additional block of text </h4>
<div id="text-4.3.10">


<p>
<code>BLOCK</code>-s can be used as wrappers.  A wrapper is a function that
receives a bit of text and puts something before and after it.  For
example, to define a wrapper that creates a table we can say:
</p>



<pre class="src src-html">
<span style="color: #b22222;">&lt;!-- </span><span style="color: #b22222;">define our wrapper </span><span style="color: #b22222;">--&gt;</span>
$(BLOCK table(cols)
  &lt;<span style="color: #0000ff;">table</span>&gt;
    &lt;<span style="color: #0000ff;">thead</span>&gt;
      &lt;<span style="color: #0000ff;">tr</span>&gt;
        $(MAP (label =&gt; cols) &lt;<span style="color: #0000ff;">td</span>&gt;$label&lt;/<span style="color: #0000ff;">td</span>&gt; $)
      &lt;/<span style="color: #0000ff;">tr</span>&gt;
    &lt;/<span style="color: #0000ff;">thead</span>&gt;
    &lt;<span style="color: #0000ff;">tbody</span>&gt;
      $(CONTENT)
    &lt;/<span style="color: #0000ff;">tbody</span>&gt;
  &lt;/<span style="color: #0000ff;">table</span>&gt; $)

<span style="color: #b22222;">&lt;!-- </span><span style="color: #b22222;">and here's how we use it </span><span style="color: #b22222;">--&gt;</span>
$(WRAP table([ <span style="color: #bc8f8f;">"Name"</span>, <span style="color: #bc8f8f;">"Phone"</span>, <span style="color: #bc8f8f;">"Email"</span> ])
  &lt;<span style="color: #0000ff;">tr</span>&gt; &lt;<span style="color: #0000ff;">td</span>&gt;Foo&lt;/<span style="color: #0000ff;">td</span>&gt; &lt;<span style="color: #0000ff;">td</span>&gt;123-1234&lt;/<span style="color: #0000ff;">td</span>&gt; &lt;<span style="color: #0000ff;">td</span>&gt;foo@foo.com&lt;/<span style="color: #0000ff;">td</span>&gt; &lt;/<span style="color: #0000ff;">tr</span>&gt;
  &lt;<span style="color: #0000ff;">tr</span>&gt; &lt;<span style="color: #0000ff;">td</span>&gt;Bar&lt;/<span style="color: #0000ff;">td</span>&gt; &lt;<span style="color: #0000ff;">td</span>&gt;1234-123&lt;/<span style="color: #0000ff;">td</span>&gt; &lt;<span style="color: #0000ff;">td</span>&gt;bar@bar.com&lt;/<span style="color: #0000ff;">td</span>&gt; &lt;/<span style="color: #0000ff;">tr</span>&gt;
$)
</pre>




<p>
You can note that the wrapper is a normal function (<code>BLOCK</code>) and it
can take arguments.  To send the arguments with a <code>WRAP</code> block, just
make it look like a normal function call.  If there are no arguments,
you still need to insert the parens <code>()</code>.  When it's calling your
block, <code>WRAP</code> sends an additional hidden argument that contains the
text which is expanded by <code>$(CONTENT)</code>.  For now this argument is a
function that renders the text, and <code>$(CONTENT)</code> simply calls this
function.
</p>
</div>

</div>

<div id="outline-container-4.3.11" class="outline-4">
<h4 id="sec-4.3.11">4.3.11 <code>EXPORT</code> &mdash; define a BLOCK that can be used in another template </h4>
<div id="text-4.3.11">


<p>
<code>EXPORT</code> is like <code>BLOCK</code>, but the function that it creates is
“exported” and can be called from different templates.  The assumption
for this to work is that all templates are compiled with the same
YAJET object instance (since it will maintain some runtime environment
for this case).
</p>
<p>
Here's a quick example:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">yajet</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">YAJET</span>();
yajet.compile(<span style="color: #bc8f8f;">"$(EXPORT foo(arg) foo got $arg $)"</span>);

<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">t1</span> = yajet.compile(<span style="color: #bc8f8f;">"$(IMPORT (foo)) ${ foo('bar') }"</span>);
alert(t1()); <span style="color: #b22222;">// </span><span style="color: #b22222;">displays "foo got bar"
</span>
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">t2</span> = yajet.compile(<span style="color: #bc8f8f;">"$(PROCESS foo('baz'))"</span>);
alert(t2()); <span style="color: #b22222;">// </span><span style="color: #b22222;">displays "foo got baz"
</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">call the exported function directly
</span>alert(yajet.process(<span style="color: #bc8f8f;">"foo"</span>, <span style="color: #5f9ea0;">null</span>, [ <span style="color: #bc8f8f;">"something"</span> ])); <span style="color: #b22222;">// </span><span style="color: #b22222;">displays "foo got something"
</span></pre>




<p>
Above you can see a few ways to call an exported block.  One is by
calling <code>$(IMPORT (block_name))</code> first, which will actually make it
available as a local function, which you can then use as if it were
defined with <code>BLOCK</code>.  The second way is using <code>$(PROCESS block_name())</code>.  <code>PROCESS</code> expects that the name of the block that you
type there is a function created with <code>EXPORT</code> and compiled <i>before</i>
the call to <code>PROCESS</code>.
</p>
<p>
It might be important to understand that compile() actually runs your
template once when it contains <code>EXPORT</code>-ed functions, so that they get
into the YAJET instance.  This shouldn't be a problem&mdash;in practice,
you will have templates that contain <i>only</i> export blocks, where you
will put utilities.  For example, above we don't store the result of
yajet.compile for the first template, since all it does is just export
the function.  The exported function gets into the YAJET object
instance.
</p>
<p>
Some notes:
</p>
<ul>
<li>
<i>the order</i> in which you compile the templates is not important.
However, when you <i>execute</i> a template you must make sure that any
dependencies were <i>already compiled</i>.

</li>
<li>
there is no namespace support, so make sure that you don't export a
block with the same name in two templates.  Typically, the second
will overwrite the first (depending on the compilation order), but
you get no warning.

</li>
<li>
within the template where they are defined, you can use exported
blocks as if they were local.  They can call each other if needed,
they can $(WRAP) each other, etc.

</li>
<li>
if you need to call a function <code>EXPORT</code>-ed from another template as
a <code>WRAP</code>-per, you need to <code>$(IMPORT)</code> it first.  Other than this,
it's the same as described in <a href="#sec-4.3.10">WRAP</a>.

</li>
<li>
as you can see above, it is possible to call an exported block
directly without using an intermediate template.  Use
<code>yajet.process(exported_name, self, [ more, args ])</code>.  The <code>self</code>
argument is accessible as <b>this</b> within the block, and the last is
an array of more arguments that are passed to the function.

</li>
</ul>
</div>

</div>

<div id="outline-container-4.3.12" class="outline-4">
<h4 id="sec-4.3.12">4.3.12 <code>LITERAL</code> &mdash; include literal text </h4>
<div id="text-4.3.12">


<p>
With this directive you can include a literal block of text.  No
constructs within it are expanded.  Example:
</p>



<pre class="example">
$this.foo -- here it's replaced with the value of the variable
$(LITERAL "STOP"
  $this.foo -- here it's left untouched
STOP)
</pre>




<p>
The <code>LITERAL</code> directive takes one string as an argument.  That string
immediately followed by a closing paren is expected to end the literal
block of text.  In the above example we state that “STOP)” should end
the text.  Note that the closing paren is implied, and required:
</p>



<pre class="example">
$(LITERAL "FOO"
  The following doesn't end the block:
  FOO
  but the following does:
  FOO)
</pre>




</div>

</div>

<div id="outline-container-4.3.13" class="outline-4">
<h4 id="sec-4.3.13">4.3.13 <code>SYNTAX</code> &mdash; temporarily change the reader character </h4>
<div id="text-4.3.13">


<p>
When you need to display the current reader char literally, many times
in a block of text, rather than typing it twice each time it's
sometimes more convenient to temporarily change it to something
different.  Example:
</p>



<pre class="src src-html">
Price: $$ $this.price
TAX:   $$ $this.tax
This is a dollar sign: $$

<span style="color: #b22222;">&lt;!-- </span><span style="color: #b22222;">here's another way: </span><span style="color: #b22222;">--&gt;</span>
$(SYNTAX #
  Price: $ #this.price
  TAX:   $ #this.tax
  This is a dollar sign: $
#)

$this.tax -- back to previous reader char
</pre>




<p>
<code>SYNTAX</code> takes a single char argument (the first non-white-space
character that follows the directive) and that char becomes the
<code>reader_char</code> while its block of text is in effect.  Note that to end
the block of text you need to include the normal block terminator, but
using the new reader char&mdash;so we need <code>#)</code> instead of <code>$)</code> in the above sample.
</p>
</div>

</div>

<div id="outline-container-4.3.14" class="outline-4">
<h4 id="sec-4.3.14">4.3.14 Literal JavaScript with <code>$( ... )</code> </h4>
<div id="text-4.3.14">


<p>
Finally, you can include literal JavaScript code, if needed, by
placing a space after the open bracket.  The code inside <code>$( ... )</code>
must be valid JavaScript and by this I mean properly balanced (you
cannot open a paren in such a block and close it in another).
</p>
<p>
For example, if you need to change the value of some variable which is
already defined, you can do this:
</p>



<pre class="example">
$( myVar = doSomething() )
  ^-- note this space.
</pre>




<p>
Unlike a <code>${ ... }</code> block, which would allow the above code as well,
this one won't place the result into the template output.  Also,
unlike a <code>${ ... }</code> block, this one allows multiple statements
separated with a semicolon:
</p>



<pre class="example">
$( foo = "bar";
   moreSideEffects();
   i = 10 )
</pre>




</div>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><a name="Correctness" id="Correctness"></a>5 Correctness </h2>
<div id="text-5">


<p>
YAJET aims to do The Right Thing.  If you've ever written Lisp or C macros,
then you know that it's dangerous to invent variable names, or to use a
macro argument more than once.  YAJET is essentially a macro expander and
it's built around these good principles.
</p>
<p>
For example, a dumb implementation would translate <code>$(FOREACH (link =&gt; links) ...STUFF... $)</code> into this:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">i</span> = 0; i &lt; links.length; ++i) {
    <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">link</span> = links[i];
    <span style="color: #b22222;">// </span><span style="color: #b22222;">... do STUFF
</span>}
</pre>




<p>
However the above code has two problems:
</p>
<ol>
<li>
if the text in <code>STUFF</code> defines a variable named <code>i</code>, then it will collide
with the loop variable.

</li>
<li>
if <code>links</code> is not a real array, but say, a (possibly expensive, and
perhaps with weird side effects) function call that returns an array,
then it will be called for each iteration&hellip; twice.

</li>
</ol>

<p>If <code>FOREACH</code> would really expand into the above code, then the following
sample would suffer from both problems:
</p>



<pre class="example">
$(FOREACH (link =&gt; this.getLinksFromServer())
  $( var i = link.text.length )
  $(WHEN (i &gt; 30)
    ... truncate text
  $)
  ...
$)
</pre>




<p>
The resulted code would be:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">i</span> = 0; i &lt; <span style="color: #5f9ea0;">this</span>.getLinksFromServer().length; ++i) {
  <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">link</span> = <span style="color: #5f9ea0;">this</span>.getLinksFromServer()[i];
  <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">i</span> = link.text.length;
  <span style="color: #a020f0;">if</span> (i &gt; 30) {
    ... truncate text
  }
  ...
}
</pre>




<p>
&hellip; which means that this.getLinksFromServer() will be called twice for each
step, and also that the loop would be stopped arbitrarily when we encounter
a link whose text has more characters than the number of links.  That would
break in unexpected and hard to debug ways.
</p>
<p>
What YAJET actually generates for the above case looks like this:
</p>



<pre class="src src-espresso">
(<span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">__GSY12</span>){
  <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">__GSY13</span> = __GSY12.length, <span style="color: #b8860b;">__GSY14</span> = 0; __GSY14 &lt; __GSY13; ++__GSY14) {
    <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">link</span> = __GSY12[__GSY14];
    <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">i</span> = link.length;
    <span style="color: #a020f0;">if</span> (i &gt; 30) {
      ... truncate text
    }
    ...
  }
}).call(<span style="color: #5f9ea0;">this</span>, <span style="color: #5f9ea0;">this</span>.getLinksFromServer());
</pre>




<p>
The variables that aren't explicitly named in the template get unique
names with the prefix <code>__GSY</code>, so you should be safe as long as you
don't use the <code>__GSY</code> prefix yourself.  Also, there are a few other
internal variables that YAJET has to use:
</p>
<ul>
<li>
<code>__EXPORTS</code> &ndash; an array where we store exported blocks
</li>
<li>
<code>__BUF</code> &ndash; a string holding the output buffer
</li>
<li>
<code>OUT</code> and <code>VUT</code>

</li>
</ul>

<p>I prefixed those that I assumed won't be generally useful with two
underscores.  <code>OUT</code> and <code>VUT</code> are not prefixed because they are needed
for custom directives.  Both of them are functions that currently do
the same thing<sup><a class="footref" name="fnr.11" href="#fn.11">11</a></sup>: they take one argument and if it's not <code>null</code>
they insert it into the output.
</p>

<hr/>

<p>
You can note in the code above that the loop block is embedded in a
function, so that it doesn't affect outside variables.  Creating
lambdas everywhere has other implications that we need to be careful
about:
</p>

</div>

<div id="outline-container-5.1" class="outline-3">
<h3 id="sec-5.1">5.1 Loop control </h3>
<div id="text-5.1">


<p>
Imagine this loop:
</p>



<pre class="example">
$(MAP (a =&gt; [1, 2, 3, 4, 5])
  $(LET ((b =&gt; a))
    $(WHEN (b &gt; 3) $(BREAK) $)
    $b
  $)
$)
</pre>




<p>
If <code>$(BREAK)</code> would translate into the plain JavaScript <code>break</code>
statement, it would be a syntax error because <code>LET</code> introduces an
anonymous function (in order not to mess with outer variables).  The
above block expands into something like the following, which <i>is</i> the
right thing:
</p>



<pre class="src src-espresso">
(<span style="color: #a020f0;">function</span> (<span style="color: #b8860b;">__GSY31</span>) {
    <span style="color: #a020f0;">for</span> (<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">__GSY32</span> = __GSY31.length, <span style="color: #b8860b;">__GSY33</span> = 0; __GSY33 &lt; __GSY32; ++__GSY33) {
        <span style="color: #a020f0;">try</span> {
            <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">a</span> = __GSY31[__GSY33];
            (<span style="color: #a020f0;">function</span> () {
                <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">b</span> = a;
                <span style="color: #a020f0;">if</span> (b &gt; 3) {
                    <span style="color: #a020f0;">throw</span> __YAJET.X_BREK; <span style="color: #b22222;">// </span><span style="color: #b22222;">this is BREAK
</span>                }
                VUT(b);
            }).call(<span style="color: #5f9ea0;">this</span>);
        }
        <span style="color: #a020f0;">catch</span> (ex) {
            <span style="color: #a020f0;">if</span> (ex === __YAJET.X_CONT) { <span style="color: #b22222;">// </span><span style="color: #b22222;">here we handle CONTINUE
</span>                <span style="color: #a020f0;">continue</span>;
            }
            <span style="color: #a020f0;">if</span> (ex === __YAJET.X_BREK) { <span style="color: #b22222;">// </span><span style="color: #b22222;">and here we handle BREAK
</span>                <span style="color: #a020f0;">break</span>;
            }
            <span style="color: #a020f0;">throw</span> ex;
        }
    }
}).call(<span style="color: #5f9ea0;">this</span>, [1, 2, 3, 4, 5]);
</pre>




<p>
So <code>BREAK</code> and <code>CONTINUE</code> are handled with exceptions, which has an
interesting implication: if you <i>know</i> that some function will <i>only</i>
be called from loops, <i>then</i> you can safely use <code>BREAK</code> and <code>CONTINUE</code>
within it.  But only <i>if you know that</i>. ;-)
</p>
</div>

</div>

<div id="outline-container-5.2" class="outline-3">
<h3 id="sec-5.2">5.2 The value of <code>this</code> </h3>
<div id="text-5.2">


<p>
Put simply, YAJET will “copy” <code>this</code> to all functions that it creates
or calls itself, so that <code>this</code> will still refer to your template
argument even if you're inside some loop or other automatically
generated function.
</p>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">6 Custom directives </h2>
<div id="text-6">


<p>
YAJET allows you to add custom directives fairly easily, though you'll
have to dig somewhat uncharted territory.  You need to pass a
<code>directives</code> hash to the constructor, in which you map directive name
to a parser function.  Your function is responsible for parsing any
arguments that you want your directive to support, and to generate any
code that your directive should expand into.
</p>
<p>
Let's start with an easy one:
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">yajet</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">YAJET</span>({
    directives: {
        <span style="color: #0000ff;">author</span>: <span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">c</span>) {
            c.out(<span style="color: #bc8f8f;">"OUT('Mihai Bazon &lt;<a href="mailto:mihai.bazon&#64;gmail.com">mihai.bazon&#64;gmail.com</a>&gt;');"</span>);
            c.assert_skip(<span style="color: #bc8f8f;">")"</span>);
        }
    }
});
</pre>




<p>
The above defines a directive that doesn't take any arguments.  You
can notice that your parser function receives one argument&mdash;it's an
object that stores the current context and provides some helper API
for you to do your stuff.  Above I used the <code>out</code> method, to output
code that should be part of the compiled template, and <code>assert_skip</code>
to force an error unless the template continues with a closing paren.
</p>
<p>
In a template compiled with the above object instance, we can now type
<code>$(AUTHOR)</code>, and it will expand into this:
</p>



<pre class="src src-espresso">
OUT(<span style="color: #bc8f8f;">'Mihai Bazon &lt;<a href="mailto:mihai.bazon&#64;gmail.com">mihai.bazon&#64;gmail.com</a>&gt;'</span>);
</pre>




<p>
In turn, when the template is executed, <code>OUT</code> will put its argument
into the output stream.
</p>
<p>
Your directive handler is free to parse any syntax that you desire,
but after it finishes the “normal” parser resumes execution for the
remainder of the code.  The “normal” is: assume plain text until we
meet the reader char, then parse according to the rules described in
this document.
</p>
<p>
Again, this isn't for everyone so I won't get into much
detail&mdash;please feel free to <a href="../js/yajet.js">read the source</a> to figure out more.  I'll
just summarize the API that the context object exposes:
</p>
<ul>
<li>
<code>peek()</code> &mdash; return the current character.
</li>
<li>
<code>next()</code> &mdash; return the current character and skip to the next one.
</li>
<li>
<code>rest()</code> &mdash; return the rest of the characters (thus, what's left to parse),
</li>
<li>
<code>out(str)</code> &mdash; insert <code>str</code> into the generated JavaScript code.
</li>
<li>
<code>set_output(array)</code> &mdash; set a new output array; subsequent <code>out()</code>
calls will push data into this array.  Returns the previous output.
</li>
<li>
<code>skip_ws(noComments)</code> &mdash; skip forward whitespace and comments.  The
optional <code>noComments</code> argument can be used (pass <code>true</code>) to avoid
skipping comments.
</li>
<li>
<code>assert(str)</code> &mdash; throw an error if <code>rest()</code> does not start with
<code>str</code> (when <code>str</code> is a string) or does not match <code>str</code> (when <code>str</code>
is a RegExp).
</li>
<li>
<code>assert_skip(str)</code> &mdash; like <code>assert(str)</code>, but call <code>skip_ws()</code>
before checking, and skip <code>str</code> if it follows (otherwise throw
exception like <code>assert</code>).
</li>
<li>
<code>skip(str)</code> &mdash; if <code>rest()</code> starts with <code>str</code> or matches <code>str</code> (when
it's a RegExp), skip the matched part.
</li>
<li>
<code>looking_at(str)</code> &mdash; return an object if <code>rest()</code> starts with <code>str</code>
or matches <code>str</code> (when it's a RegExp); returns undefined otherwise.
The object contains: "match" which is the full matched text,
"length" which is the length of the match and "groups" in the case
when <code>str</code> is a regexp (the result of <code>regexp.match</code>).
</li>
<li>
<code>block_open(open, close)</code> &mdash; call <code>out(open)</code> to start a new block,
and push <code>close</code> so that it gets output when <code>$)</code> is encountered.
<code>close</code> is an optional argument (it defaults to "}" when not passed,
since it's the usual JS block terminator).  It can be a function, in
which case it's simply called when <code>$)</code> is found, and it's
responsible for pushing any required code to end the current block
using <code>c.out</code>.
</li>
<li>
<code>block_close()</code> &mdash; close the current block (you shouldn't need to
call this manually).
</li>
<li>
<code>read_balanced(wantList)</code> &mdash; read balanced expression.  The current
character must be some open paren, and it will read, skipping
strings, comments and whitespace, until the paren is closed.  The
optional <code>wantList</code> argument specifies if the return value should be
an array that contains the elements of the parsed list, or just a
string.  Return <code>null</code> if no list starts now.
</li>
<li>
<code>read_string()</code> &mdash; read and return a JavaScript string.  The
current character must be a string quote.  Return the string if it
was available, or null otherwise.
</li>
<li>
<code>read_simple_token()</code> &mdash; try to read and return if available a
JavaScript identifier.  Note that the syntax is somewhat extended in
that it will return for instance "foo.bar|baz" as a single token.
</li>
<li>
<code>read_valist()</code> &mdash; parse and return a variable list such as those
used for <code>LET</code>.  A side effect is that this also outputs the <code>var</code>
declaration.
</li>
<li>
<code>to_js_string(str)</code> &mdash; adds quotes and escapes special characters
(newlines, tabs, quotes and backslashes) in <code>str</code> to form a
JavaScript string.
</li>
<li>
<code>trim(str)</code> &mdash; remove leading and trailing whitespace from <code>str</code> and
return the trimmed string.
</li>
<li>
<code>map(a, f, obj)</code> &mdash; for each element of array <code>a</code> call function <code>f</code> in
the context of <code>obj</code> and collect the returned values.
</li>
<li>
<code>EX_PARSE(error_str)</code> &mdash; throw a parse exception.
</li>
<li>
<code>directives</code> &mdash; a hash containing the <code>directives</code> that you passed
in constructor.  You can insert new directives at “compile-time”
into this hash.  This hack is used in the <code>SWITCH</code> example below.

</li>
</ul>

<p>You should understand that your custom directives run at <i>compile time</i>.  So “c.out” does not produce the final template result;
instead, it should produce JavaScript <i>code</i> that generates the final
result when executed.  This is why our sample above doesn't simply say
<code>c.out("author...")</code>, instead it has to say
<code>c.out("OUT('author...');")</code>.  The <code>OUT</code> function is available at
run-time and inserts text as part of the final result.
</p>

</div>

<div id="outline-container-6.1" class="outline-3">
<h3 id="sec-6.1">6.1 A more involved example &mdash; <code>SWITCH</code> </h3>
<div id="text-6.1">


<p>
For a non-trivial example, here's how to implement a <code>SWITCH</code>
directive.  It has the same semantics as the standard JavaScript
<code>SWITCH</code> &mdash; that is, depending on the value of some expression, it
selects and executes a <code>CASE</code>.  The <code>DEFAULT</code> case is executed when no
other case matches the expression.  We will in fact make use of the
standard JavaScript <code>switch</code> for this.
</p>



<pre class="src src-espresso">
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">directives</span> = {
    <span style="color: #bc8f8f;">"switch"</span>: <span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">c</span>) {
        <span style="color: #b22222;">// </span><span style="color: #b22222;">SWITCH expects one expression in parens:
</span>        <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">args</span> = c.read_balanced(<span style="color: #5f9ea0;">true</span>);
        <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">expr</span> = args[0]; <span style="color: #b22222;">// </span><span style="color: #b22222;">here is the argument
</span>
        <span style="color: #b22222;">// </span><span style="color: #b22222;">save old meaning of CASE and DEFAULT, if any
</span>        <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">old_case</span> = c.directives[<span style="color: #bc8f8f;">"case"</span>];
        <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">old_defa</span> = c.directives[<span style="color: #bc8f8f;">"default"</span>];

        <span style="color: #b22222;">// </span><span style="color: #b22222;">inject the CASE directive
</span>        c.directives[<span style="color: #bc8f8f;">"case"</span>] = <span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">c</span>) {
            <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">args</span> = c.read_balanced(<span style="color: #5f9ea0;">true</span>);
            <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">expr</span> = args[0];
            c.set_output(save);
            c.block_open(
                <span style="color: #bc8f8f;">"case "</span> + expr + <span style="color: #bc8f8f;">":"</span>,
                <span style="color: #a020f0;">function</span>() {
                    c.out(<span style="color: #bc8f8f;">"break;"</span>);
                    c.set_output([]);
                }
            );
        };

        <span style="color: #b22222;">// </span><span style="color: #b22222;">and the DEFAULT directive
</span>        c.directives[<span style="color: #bc8f8f;">"default"</span>] = <span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">c</span>) {
            c.set_output(save);
            c.block_open(
                <span style="color: #bc8f8f;">"default:"</span>,
                <span style="color: #a020f0;">function</span>() {
                    c.out(<span style="color: #bc8f8f;">"break;"</span>);
                    c.set_output([]);
                }
            );
        };

        <span style="color: #b22222;">// </span><span style="color: #b22222;">finally, open the switch block and prepare to close
</span>        <span style="color: #b22222;">// </span><span style="color: #b22222;">and restore everything when the block ends.
</span>        c.block_open(
            <span style="color: #b22222;">// </span><span style="color: #b22222;">open
</span>            <span style="color: #bc8f8f;">"switch ("</span> + expr + <span style="color: #bc8f8f;">") {"</span>,
            <span style="color: #b22222;">// </span><span style="color: #b22222;">close
</span>            <span style="color: #a020f0;">function</span>() {
                c.set_output(save);
                c.directives[<span style="color: #bc8f8f;">"case"</span>] = old_case;
                c.directives[<span style="color: #bc8f8f;">"default"</span>] = old_defa;
                c.out(<span style="color: #bc8f8f;">"}"</span>);
            }
        );

        <span style="color: #b22222;">// </span><span style="color: #b22222;">any text between these directives is not interesting.
</span>        <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">save</span> = c.set_output([]);
    }
};
<span style="color: #a020f0;">var</span> <span style="color: #b8860b;">yajet</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">YAJET</span>({
    directives: directives
});
</pre>




<p>
And now, you can use <code>SWITCH</code> in your templates:
</p>



<pre class="example">
$(SWITCH ("foo")
   $(CASE ("bar") This won't be written. $)
   $(CASE ("foo") But this will. $)
   $(DEFAULT And this not. $)
$)
</pre>




<p>
The implementation of <code>SWITCH</code> needs to be a bit complex.  We insert
the <code>CASE</code> and <code>DEFAULT</code> directives when our <code>SWITCH</code> directive runs
(that is, when the template is compiled), but remove them once the
<code>SWITCH</code> block is ended (since they don't make sense outside
<code>SWITCH</code>).  We need to use <code>set_output</code> to change the output array to
some temporary one which we will discard, because otherwise the
whitespace between <code>$(SWITCH (...)</code> and the first <code>$(CASE)</code> will be
transformed into code, and it won't be valid JavaScript syntax.  And
we need to be careful to set the output back to the saved value when
needed<sup><a class="footref" name="fnr.12" href="#fn.12">12</a></sup>.
</p>
<p>
This topic is advanced so I will stop here.  If you want to write your
own directives, you are assumed to have some good JavaScript knowledge
and dig through the code for more (and/or ask on the <a href="http://groups.google.com/group/yajet">YAJET group</a>, but
preferably after you have something to show us).
</p>


</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><a name="Known==issues" id="Known==issues"></a>7 Known issues </h2>
<div id="text-7">



</div>

<div id="outline-container-7.1" class="outline-3">
<h3 id="sec-7.1">7.1 Literal RegExp-s in JavaScript expressions </h3>
<div id="text-7.1">


<p>
The JavaScript scanner is not “complete”, although it's smart enough
to skip comments and strings while looking for a closing paren.
Literal regexps are tricky to figure out, so I left this out for now.
What this means is that you should be careful about parens in literal
RegExp-s.  Since the parser does not allow for unbalanced parens, the
following should <i>not</i> be a problem:
</p>



<pre class="src src-espresso">
$( <span style="color: #a020f0;">if</span> (<span style="color: #bc8f8f;">/(a|b)/</span>.test(<span style="color: #bc8f8f;">"bar"</span>)) {
     matches();
   } <span style="color: #a020f0;">else</span> {
     no_match();
   }
 )
</pre>




<p>
All parens are properly closed, so there's no reason why our parser should
miss the closing paren.  However, the following will break stuff:
</p>



<pre class="src src-espresso">
$( <span style="color: #a020f0;">if</span> (<span style="color: #bc8f8f;">/\)/</span>.test(<span style="color: #bc8f8f;">")"</span>)) { ... } )
</pre>




<p>
Although it is valid JavaScript inside, having the closing paren in the
RegExp will confuse YAJET.  It looks quite ugly, too&mdash;for such cases,
encode the paren as <code>\x29</code>.  Note that you have to escape open parens as
well (<code>\x28</code>), and same goes for all the other types of brackets such as
<code>[</code>, <code>]</code>,  <code>{</code> and <code>}</code>.
</p>
</div>

</div>

<div id="outline-container-7.2" class="outline-3">
<h3 id="sec-7.2">7.2 Error reporting is less than ideal </h3>
<div id="text-7.2">


<p>
While YAJET is smart enough to scan complicated constructs, it will
not do any syntax checking on its own.  It just scans your template
and generates JS code.  Then it compiles a function (using the
<a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Function">Function</a> constructor).  At this point the browser (its JavaScript
engine) does the proper syntax checking and error reporting.  If
anything goes wrong, you do get an error, but it's less informative
than it could be.  If you're using Firebug or Google Chrome, the
generated code will show up in the console so you get a chance to see
what's wrong, but don't trust the line number or file that its
displayed there.
</p>
<p>
I don't see me writing a full JavaScript parser anytime soon, so for
the time being we will have to live with this.  It's still pretty
good. ;-)
</p>
</div>

</div>

<div id="outline-container-7.3" class="outline-3">
<h3 id="sec-7.3">7.3 Whitespace handling </h3>
<div id="text-7.3">


<p>
Currently YAJET keeps all whitespace in the generated
source<sup><a class="footref" name="fnr.13" href="#fn.13">13</a></sup>.  There is a directive that allows you to say
“kill following whitespace” (<code>$-</code>, that is, the reader char followed
by a minus sign) but it's not very convenient.  For example:
</p>



<pre class="src src-html">
&lt;<span style="color: #0000ff;">p</span>&gt;
$(IF (true)
  foo
$(ELSE)
  bar
$)
&lt;/<span style="color: #0000ff;">p</span>&gt;
</pre>




<p>
results in this output:
</p>



<pre class="src src-html">
&lt;<span style="color: #0000ff;">p</span>&gt;

  foo

&lt;/<span style="color: #0000ff;">p</span>&gt;
</pre>




<p>
Generally, it's not what one would expect.  We can make it look better
with the “kill whitespace” directive, but it's totally unintuitive:
</p>



<pre class="src src-html">
&lt;<span style="color: #0000ff;">p</span>&gt;$-
$(IF (true)
  foo$-
$(ELSE)
  bar$-
$)
&lt;/<span style="color: #0000ff;">p</span>&gt;
</pre>




<p>
This outputs better:
</p>



<pre class="src src-html">
&lt;<span style="color: #0000ff;">p</span>&gt;
  foo
&lt;/<span style="color: #0000ff;">p</span>&gt;
</pre>




<p>
So the default behavior should probably be:
</p>
<ul>
<li>
if a line starts with whitespace followed by a directive, the whitespace
should be eaten.

</li>
<li>
if a line ends with a block close paren (<code>$)</code>) followed only by
whitespace, then that whitespace + the newline will be eaten.

</li>
</ul>

<p>Need to think about it a bit more.  However, fortunately in HTML whitespace
is not too important.
</p>
</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">8 How to get help </h2>
<div id="text-8">


<p>
If you have any questions please post them on the <a href="http://groups.google.com/group/yajet">YAJET Google Group</a>.
</p>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9">9 License </h2>
<div id="text-9">


<p>
Copyright (c) 2010, <a href="http://mihai.bazon.net/blog">Mihai Bazon</a>, Dynarch.com.  All rights reserved.
</p>
<p>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
</p>
<ul>
<li>
Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

</li>
<li>
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

</li>
<li>
Neither the name of Dynarch.com nor the names of its contributors may
be used to endorse or promote products derived from this software
without specific prior written permission.

</li>
</ul>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</p>













</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> The misspelling is intentional.  Various combinations of the
letters Y, A, J, T, E from “Yet Another JavaScript Template Engine” led to
the name YAJET.  YAJET stands for “Yet Another JavaScript Emplate Tengine”.
Sounds buzzy, isn't it?  Also, <a href="http://en.wikipedia.org/wiki/Jet_engine">JET</a>-s are fast, and so is YAJET.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> You can still put literal JavaScript inside using <code>$( ... )</code>, but it has to be properly balanced.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.3" href="#fnr.3">3</a></sup> I added this because it was easy, and it can be useful
for one-liners, but I vote against it for blocks bigger than a few
lines.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.4" href="#fnr.4">4</a></sup> <a href="http://beebole.com/pure/">Pure</a> comes first on Google when we search “JavaScript
template engine”.  Have you notice how exaggeratedly creepy is the
syntax for <a href="http://beebole.com/pure/documentation/iteration-with-directives/">rendering with directives</a>?  I guess we truly live in a
“<a href="http://en.wikipedia.org/wiki/Worse_is_better">worse is better</a>” world, but I'm still trying to do The Right Thing.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.5" href="#fnr.5">5</a></sup> This is a double-feature: we have good documentation and
lots of features for small code. ;-)
</p>
<p class="footnote"><sup><a class="footnum" name="fn.6" href="#fnr.6">6</a></sup> Sarcasm intended.  I still can't figure out why all other
template solutions insist on not using plain parens.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.7" href="#fnr.7">7</a></sup> Note that the JavaScript rules for falsity are
different, and I think less useful: an empty array will stand <code>true</code>,
while the number 0 (zero) is <code>false</code>.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.8" href="#fnr.8">8</a></sup> BTW, did you know that in JavaScript the expression <b>(0 == false)</b> evaluates to <b>true</b> in conditionals?
</p>
<p class="footnote"><sup><a class="footnum" name="fn.9" href="#fnr.9">9</a></sup> Seriously though, everything under an <code>with</code> block is
s&hellip;l&hellip;o&hellip;w&hellip; &ndash; so, while this makes for a nice syntax, you should not
use it where speed is critical.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.10" href="#fnr.10">10</a></sup> Since I'm not sure what are the benefits of the <code>let</code>
keyword from JavaScript 1.7 compared to using an anonymous function, I
decided not to add a browser check for this.  When more browsers will
support it I'll change my mind.  But the template syntax will remain
the same.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.11" href="#fnr.11">11</a></sup> <code>VUT</code> however might change in the future.  <code>OUT</code> is intended
to output plain text, while <code>VUT</code> is meant to output the value of an
expression.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.12" href="#fnr.12">12</a></sup> The fact that JavaScript properly supports closures
plays a key role into all this, but <a href="http://mihai.bazon.net/blog/the-buzz-of-closures">I'm tired</a> of saying this all
over. :-)
</p>
<p class="footnote"><sup><a class="footnum" name="fn.13" href="#fnr.13">13</a></sup> Speaking of it, most (all?) template engines do the
same.
</p>
</div>
</div>
<div id="postamble"><p class="author"> Author: Mihai Bazon
<a href="mailto:mihai.bazon@gmail.com">&lt;mihai.bazon@gmail.com&gt;</a>
</p>
<p class="date"> Date: 2010-05-30 10:45:08 CEST</p>
<p>HTML generated by org-mode 6.21b in emacs 23</p>
</div></body>
</html>
