<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>YAJET &ndash; JavaScript Emplate Tengine</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2010-05-01 12:31:16 CEST"/>
<meta name="author" content="Mihai Bazon"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color:lightblue; font-weight:normal }
  .target { }
  .timestamp { color: grey }
  .timestamp-kwd { color: CadetBlue }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="docstyle.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*/-->
</script>
</head><body>
<h1 class="title">YAJET &ndash; JavaScript Emplate Tengine</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Yet Another JavaScript Emplate Tengine[1] </a></li>
<li><a href="#sec-2">2 What makes it different? </a></li>
<li><a href="#sec-3">3 Features </a></li>
<li><a href="#sec-4">4 Usage </a>
<ul>
<li><a href="#sec-4.1">4.1 Template arguments </a></li>
<li><a href="#sec-4.2">4.2 Reader char </a></li>
</ul>
</li>
<li><a href="#sec-5">5 Syntax </a>
<ul>
<li><a href="#sec-5.1">5.1 Simple interpolation (the <code>$foo</code> construct) </a></li>
<li><a href="#sec-5.2">5.2 JavaScript expressions (the <code>${exp}</code> construct) </a>
<ul>
<li><a href="#sec-5.2.1">5.2.1 Filters </a></li>
</ul>
</li>
<li><a href="#sec-5.3">5.3 Directives </a>
<ul>
<li><a href="#sec-5.3.1">5.3.1 <code>IF</code> / <code>WHEN</code> / <code>UNLESS</code>, <code>ELSE</code> / <code>ELSIF</code> &mdash; conditional execution </a></li>
<li><a href="#sec-5.3.2">5.3.2 <code>REPEAT</code> / <code>LOOP</code> &mdash; to repeat stuff </a></li>
<li><a href="#sec-5.3.3">5.3.3 <code>MAP</code> / <code>FOREACH</code> &mdash; iterate an array </a></li>
<li><a href="#sec-5.3.4">5.3.4 <code>MAPHASH</code> &mdash; iterate an object (hash) </a></li>
<li><a href="#sec-5.3.5">5.3.5 <code>CONTINUE</code> and <code>BREAK</code> &mdash; for loop control </a></li>
<li><a href="#sec-5.3.6">5.3.6 <code>LET</code> and <code>VAR</code> &mdash; define variables </a></li>
<li><a href="#sec-5.3.7">5.3.7 <code>WITH</code> &mdash; modify the scope chain </a></li>
<li><a href="#sec-5.3.8">5.3.8 <code>BLOCK</code> and <code>FUNCTION</code> &mdash; define reusable template blocks </a></li>
<li><a href="#sec-5.3.9">5.3.9 <code>WRAP</code>, <code>CONTENT</code> &mdash; call a wrapper with an additional block of text </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-6">6 Correctness </a></li>
<li><a href="#sec-7">7 Known issues </a>
<ul>
<li><a href="#sec-7.1">7.1 Literal RegExp-s in JavaScript expressions </a></li>
<li><a href="#sec-7.2">7.2 Error reporting is less than ideal </a></li>
<li><a href="#sec-7.3">7.3 Whitespace handling </a></li>
</ul>
</li>
<li><a href="#sec-8">8 License </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1 Yet Another JavaScript Emplate Tengine<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup> </h2>
<div id="text-1">


<p>
A “template engine” is a tool able to transform some text into another, by
interpreting/replacing various patterns in the source text.  YAJET is such a
tool designed for client-side (JavaScript, in-browser) transformation.
</p>
<p>
YAJET is a compiler, in the sense that it transforms your template into
runnable JavaScript code; after compiling a template you get a function
which you can call with data required to fill your template, and it returns
it rendered.
</p>
<p>
YAJET is appropriate for any kind of text templates &ndash; it was not designed
specifically for HTML, although that's mostly what we use it for.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2 What makes it different? </h2>
<div id="text-2">


<p>
I'm hot happy with the syntax of various template tools.  Let's face it,
they're all creepy.  How many times have you seen stuff like this in PHP
code:
</p>



<pre class="example">
&lt;?php if (...) { ?&gt;

... two
... thousand
... lines
... here

&lt;?php } ?&gt;
</pre>




<p>
At some point the code becomes write only: you have no clue what's going on
and where, you can't fix it, all you can do is add another IF.
</p>
<p>
The defining quality, I think, of YAJET is that, while it allows you to pass
literal JavaScript code<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup>, it doesn't allow you to pass
unbalanced structures.  In other words, it's impossible to start a literal
JS block in a part of the template and end it in some other part.
</p>
<p>
The syntax that I'm proposing encourages you to split your template into
small components and call them where appropriate; blocks should not become
very long in this way.  It shares some conceptual similarities with the
venerable <a href="http://template-toolkit.org/">Template::Toolkit</a> (which is probably the best template engine I've
used so far) and some syntactic ones with Lisp.
</p>
<p>
Also see <a href="#sec-6">Correctness</a>.
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3 Features </h2>
<div id="text-3">


<p>
Other than the boring variable replacement, YAJET supports the following
(and I will explain them all in this document):
</p>
<ul>
<li>
conditionals (<code>IF</code> / <code>WHEN</code> / <code>UNLESS</code>, <code>ELSE</code>, <code>ELSIF</code>).  <code>WHEN</code> is a
synonym to <code>IF</code>, and <code>UNLESS</code> is, of course, the complete opposite.
<code>ELSE</code> and <code>ELSIF</code> are supported both in <code>IF/WHEN</code> and in <code>UNLESS</code> blocks,
but using <code>ELSE</code> in an <code>UNLESS</code> block makes the code look a bit werid.

</li>
<li>
repetitive constructs (<code>REPEAT</code> / <code>LOOP</code>).  They allow you to repeat a
part of the template a few times. <code>LOOP</code> is a synonym to <code>REPEAT</code>.

</li>
<li>
iterating array or hashes (<code>MAP</code> and <code>MAPHASH</code>) &ndash; <code>MAP</code> to traverse a
list and <code>MAPHASH</code> to iterate an object (hash table).

</li>
<li>
all loops can be controlled by <code>BREAK</code> or <code>CONTINUE</code>.

</li>
<li>
variable definition (<code>LET</code>, <code>VAR</code> and <code>WITH</code>).  <code>LET</code> and <code>WITH</code> introduce
new lexical scopes.

</li>
<li>
components (<code>BLOCK</code> and <code>FUNCTION</code>).  Useful to declare a block that can
be called as a function.  <code>BLOCK</code> will feed its output into the main
output stream, while <code>FUNCTION</code> will return it.  Both are closures within
their lexical context.

</li>
<li>
components can be called using <code>WRAP</code>.  They receive some content and are
able to output something before and after it.

</li>
<li>
simple filters a la Template::Toolkit (i.e. <code>$foo|html</code> will HTML-escape
the value of foo).

</li>
<li>
it compiles the template into a runnable JavaScript function which is
blazing fast.

</li>
<li>
it does not use eval().

</li>
<li>
the code is shorter than the documentation (~500 lines of code, 5.5K
minified, 2.2K gzipped) and it's completely self-contained (no library
requirements, and it should not clash with any library).

</li>
</ul>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">4 Usage </h2>
<div id="text-4">


<p>
You need to load <a href="../js/yajet.js">yajet.js</a>, and to create an instance like this:
</p>



<pre class="example">
var yajet = new YAJET({
    reader_char : "$",
    with_scope  : false,
    filters     : {
        foo: function(val) { ... },
        bar: function(val) { ... }
    }
});
</pre>




<p>
All arguments are optional.  Then to compile a template, you do this:
</p>



<pre class="example">
var func = yajet.compile("You said: $this.foo $this.bar");
</pre>




<p>
and to execute it:
</p>



<pre class="example">
alert( func({ foo: "hello", bar: "world!" }) );
</pre>





</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1">4.1 Template arguments </h3>
<div id="text-4.1">


<p>
The function created by “yajet.compile” receives one argument, and that
argument is available in your templates via the JavaScript <code>this</code> keyword.
This is the default behavior, because I think it's the best one in general,
but if you don't like to use the <code>this.</code> prefix to access the members you
can pass <code>with_scope: true</code> in the constructor.  It wraps the generated
function in a <code>with(this) { ... }</code> block, so the above would become:
</p>



<pre class="example">
var yajet = new YAJET({ with_scope: true });
var func = yajet.compile("You said: $foo $bar");
// and call it the same way:
alert( func({ foo: "hello", bar: "world!" }) );
</pre>




<p>
It's more convenient, but it's slower (more than 10 times slower sometimes).
How much slower depends on how big is your template and how many variables
there are.  If you want a performance benchmark with and without the <code>with</code>
statement, <a href="../test/with.html">see this file</a> (Firebug is required for timing the operations;
watch the Firebug console; it also works in Chrome with its JavaScript
console; Chrome is even slower than Firefox for the <code>with</code> case).
</p>
</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2">4.2 Reader char </h3>
<div id="text-4.2">


<p>
Template syntax is triggered by a special “reader char”.  By default this
character is <code>$</code>, but you can use anything else by passing the <code>reader_char</code>
constructor argument.  I personally would prefer to use some Unicode
character, for instance:
</p>



<pre class="example">
var yajet = new YAJET({ reader_char: "•" });
var tmpl = yajet.compile("You said •foo •bar");
</pre>




</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">5 Syntax </h2>
<div id="text-5">


<p>
YAJET parses the template as text, leaving it unchanged, until it encounters
the “reader char”.  What follows in this document will assume that $ is the
reader character (the default).  A few types of constructs are recognized:
</p>
<ul>
<li>
<code>$$</code> &mdash; inserts a literal $ character.

</li>
<li>
<code>$-</code> &mdash; kills the following whitespace.

</li>
<li>
<code>$foo</code> &mdash; inserts the value of the variable foo.

</li>
<li>
<code>${ foo.bar.baz() }</code> &mdash; evaluates the given JavaScript expression and
inserts the return value, if any.

</li>
<li>
<code>$(INSTRUCTION ... $)</code> &mdash; processes the contents according to some rules
which are particular for INSTRUCTION.

</li>
<li>
<code>$( ... )</code> &mdash; inserts literal JavaScript code (must not be ill-formed!).

</li>
</ul>

</div>

<div id="outline-container-5.1" class="outline-3">
<h3 id="sec-5.1">5.1 Simple interpolation (the <code>$foo</code> construct) </h3>
<div id="text-5.1">


<p>
To insert a variable you can say <code>$foo</code>, <code>$foo.bar</code>, etc.  This case is
quite simple.  The parser will stop at a character which isn't a letter, a
digit, an underscore or a dollar sign.  Additionally it supports filtering
the values with a convenient syntax: <code>$foo|html</code>.
</p>
<p>
Filters are functions that take one argument and should return the modified
value.  You can easily define your own filters (but later on this).  Filters
can be combined, for example: <code>$foo|upcase|html</code> will first make foo
uppercase, then apply the html filter to the upcased string.
</p>
</div>

</div>

<div id="outline-container-5.2" class="outline-3">
<h3 id="sec-5.2">5.2 JavaScript expressions (the <code>${exp}</code> construct) </h3>
<div id="text-5.2">


<p>
This is similar to the “simple interpolation” case, but it allows for more
complicated expressions.  For example <code>${a+b}</code> will insert the sum of a and
b.  Your expression can be arbitrarily complex, and the scanner is smart
enough to read it, provided that it is valid JavaScript code (you need to be
<b>careful about literal RegExp-s</b> though, for now; I'll fix this in a later
release; more on this in <a href="#sec-5.2">Known issues</a>).
</p>
<p>
So, an example of a perfectly valid call is:
</p>



<pre class="example">
${
   // Comments are allowed and can even contain the closing bracket: }
   // it's ignored, since it is in a comment.
   (function(arg){
     return arg.a + arg.b + arg.text;
   })({
     a: 5,
     b: 10,
     text: "(foo}"
   })
}
</pre>




<p>
The expression is evaluated at runtime and its value is inserted into the
template output only if it's not null.
</p>

</div>

<div id="outline-container-5.2.1" class="outline-4">
<h4 id="sec-5.2.1">5.2.1 Filters </h4>
<div id="text-5.2.1">


<p>
As already noted, the <code>$foo</code> construct allows filtering the value through
some function using a convenient syntax like <code>$foo|html</code>.  At the time of
this writing the filters available by default are:
</p>
<ul>
<li>
<code>html</code> &mdash; encodes HTML special characters
</li>
<li>
<code>upcase</code> &mdash; converts the string to uppercase
</li>
<li>
<code>downcase</code> &mdash; lowercase the string
</li>
<li>
<code>trim</code> &mdash; removes leading and trailing whitespace

</li>
</ul>

<p>It's easy to define custom filters when you construct the YAJET object:
</p>



<pre class="example">
var yajet = new YAJET({
    filters: {
        md5: function(value) {
            return md5_hex_of(value); // return the modified value
        }
    }
});
</pre>




<p>
&hellip; and in your template: <code>$password|md5</code>.
</p>
<p>
There is also a syntax that allows for filters within the <code>${exp}</code>
construct.  But since we parse valid JavaScript code, and since the pipe is
a valid JavaScript character (“bitwise or”), we have to use something
different.  The idea was, thus, that such expressions will be parsed as a
list; the first element of the list is the expression itself, and any
additional elements are filters.  For example:
</p>



<pre class="example">
${ this.getLabel(), upcase, html }
</pre>




<p>
will convert into something like this:
</p>



<pre class="example">
output_string(
  apply_html_filter(
    apply_upcase_filter(
      this.getLabel()
    )
  )
)
</pre>




<p>
Since the comma doesn't look very nice for this particular case, the “list
reader” also allows a few aliases.  Syntactic sugar, baby!  You can also
use:
</p>
<ul>
<li>
<code>“=&gt;”</code>
</li>
<li>
<code>“;”</code>
</li>
<li>
<code>“..”</code>
</li>
<li>
<code>“;”</code>
</li>
<li>
<code>“IN”</code> (case insensitive, but <i>must</i> be preceded by whitespace)

</li>
</ul>

<p>So the above example can also be written like this:
</p>



<pre class="example">
${ this.getLabel() IN upcase, html }
${ this.getLabel() =&gt; upcase =&gt; html }
${ this.getLabel() =&gt; upcase, html }
${ this.getLabel() .. upcase; html }
</pre>




<p>
These special separators only work for the “list reader”, which is used in
the <code>${exp}</code>-like constructs (and several others).  Also, note that filters
are only interpreted in the top-level elements of this list, so for instance
the following won't apply the "html" filter to “foo”: <code>${ something(foo, html) }</code>.  It will just call, instead, the function <code>something</code>, passing the
variables <code>foo</code> and <code>html</code>, which is expected behavior.
</p>
<p>
When used in the <code>${exp}</code> construct, filters can receive additional
arguments.  For example, assuming you have some date formatting library, you
can easily define a filter that formats a Date object according to the
arguments:
</p>



<pre class="example">
var yajet = new YAJET({
    filters: {
        format_date: function(date, format) {
            // ... now return the *date* formatted according to *format*
        }
    }
});

// and in the template:

“Today is: ${ new Date() =&gt; format_date("YYYY-MM-DD") }”
</pre>




<p>
The first argument of your filter is always the value from the template (in
the above case, the Date object created with <code>new Date()</code>), and the other
arguments are passed following the filter name ("YYYY-MM-DD").
</p>
</div>
</div>

</div>

<div id="outline-container-5.3" class="outline-3">
<h3 id="sec-5.3">5.3 Directives </h3>
<div id="text-5.3">


<p>
So far we are able to introduce arbitrary JavaScript variables and
expressions in the template.  However that's hardly enough.  First off, the
expressions must be well-formed, so there is no way to start a JavaScript
block somewhere and end it some place else.  The following is invalid for
obvious reasons:
</p>



<pre class="example">
${ if (link != null) { }
  &lt;a href="$link|html"&gt;$link&lt;/a&gt;
${ } }
</pre>




<p>
I emphasize that the lack of support for partial expressions is a <i>feature</i>,
not a limitation.  This will never be “fixed”.  To support constructs like
the above but without encouraging poorly written templates that start a
block on line 10 and end it on line 1000, we have a few special processing
directives.  Let's call these the <code>$(BAR ... $)</code> construct.  To start with,
here is how you would write the above code:
</p>



<pre class="example">
$(IF (link != null)
  &lt;a href="$link|html"&gt;$link&lt;/a&gt;
$)
</pre>




<p>
Note that you still can start a block on one line and end it on another, but
the style is a bit different.  Instead of inserting arbitrary code
unconditionally, we simply end a known construct.  The condition that you
pass to WHEN must be fully valid JavaScript (you cannot pass a partial
expression there) and, if your editor does a good job about matching parens,
then you can quickly see where the block begins/ends by moving the cursor to
the parens.  I prefer this style.
</p>
<p>
Note that the processing instructions are not case-sensitive.  I prefer to
use UPPERCASE for them so that they stand out visually.
</p>
<p>
The <code>$(BAR ... $)</code> construct has the following properties:
</p>
<ul>
<li>
it starts with <code>$(</code> (so it's a normal paren, not a bracket).
</li>
<li>
it continues with a special instruction (again, I prefer uppercase for
this but it's not required).
</li>
<li>
depending on the instruction, certain arguments may follow.
</li>
<li>
it <i>should</i> end with <code>$)</code>.
</li>
<li>
it may contain a <i>block of text</i> between the arguments and the <code>$)</code>
terminator.

</li>
</ul>

<p>The <i>block of text</i> is parsed normally, so it's interpreted as plain text
until <code>$</code> (the reader char) is encountered, then what follows the reader
char is processed by the rules I described in this document.
</p>
<p>
Following I will describe the directives available at this time.  I think
the set of them is quite comprehensive and allows you to express any kind of
template in a simple and consistent manner.
</p>

</div>

<div id="outline-container-5.3.1" class="outline-4">
<h4 id="sec-5.3.1">5.3.1 <code>IF</code> / <code>WHEN</code> / <code>UNLESS</code>, <code>ELSE</code> / <code>ELSIF</code> &mdash; conditional execution </h4>
<div id="text-5.3.1">


<p>
<code>IF</code> and <code>WHEN</code> are synonyms, while <code>UNLESS</code> is the antonym.  <code>WHEN</code> seems more
appropriate for cases where you don't have an <code>ELSE</code> clause.  They support one
argument which must be a condition enclosed in parens.  Examples:
</p>



<pre class="example">
$(WHEN (user_id == null)
  &lt;a href="..."&gt;Please login&lt;/a&gt; $)

$(UNLESS (user_id != null)
  &lt;a href="..."&gt;Please login&lt;/a&gt; $)

$(IF (a &lt; b)
  &lt;p&gt;A is smaller&lt;/p&gt;
$(ELSIF (a &gt; b))
  &lt;p&gt;B is smaller&lt;/p&gt;
$(ELSE)
  &lt;p&gt;A and B are equal&lt;/p&gt; $)
</pre>




<p>
Note that you can use <code>ELSE</code> or <code>ELSIF</code> inside <code>UNLESS</code> or <code>WHEN</code> blocks
too, although I would not advise to use this style:
</p>



<pre class="example">
$(UNLESS (a == b)
  they are different
$(ELSE)
  they are equal $)
</pre>




<p>
You should also note that <code>ELSE</code> and <code>ELSIF</code> are not actually parsed like
other instructions.  They don't take a block of text, and thus they don't
need to end with <code>$)</code>.  Whether to do it this way was hard to decide, but
since <code>ELSE</code> and <code>ELSIF</code> normally <i>continue</i> an IF block, instead of ending
it, it seems to make sense this way.  The same applies to <code>$(BREAK)</code> and
<code>$(CONTINUE)</code> directives.
</p>
</div>

</div>

<div id="outline-container-5.3.2" class="outline-4">
<h4 id="sec-5.3.2">5.3.2 <code>REPEAT</code> / <code>LOOP</code> &mdash; to repeat stuff </h4>
<div id="text-5.3.2">


<p>
To repeat a part of the template you can use <code>REPEAT</code> or <code>LOOP</code> (they are
synonyms).  For example, the following outputs “foo” 3 times: <code>$(REPEAT (3) foo $)</code>.  In various cases you might need to know the current iteration too,
so you can pass a variable name for it:
</p>



<pre class="example">
$(REPEAT (5, i)
  Item $i $)
</pre>




<p>
The variable <code>i</code> takes values from 1 to 5 (inclusively) and the output will
be “Item 1 Item 2 ” etc.  In some cases you might want to specify an
interval (so that you start from something else than 1), so the following is
allowed:
</p>



<pre class="example">
$(LOOP (5 .. 10 =&gt; i)
  &lt;a href="/page$i"&gt;Page $i&lt;/a&gt; $)
</pre>




<p>
The <code>LOOP</code> keyword seems to be nicer in this case, but again, they are
synonyms.  Also note that the arguments are parsed using the “list reader”,
so you can use syntactic sugar to separate them (although a simple comma
would do).
</p>
</div>

</div>

<div id="outline-container-5.3.3" class="outline-4">
<h4 id="sec-5.3.3">5.3.3 <code>MAP</code> / <code>FOREACH</code> &mdash; iterate an array </h4>
<div id="text-5.3.3">


<p>
Again, <code>MAP</code> and <code>FOREACH</code> are synonyms.  You can use them to do something
for each element of an array.  For example the following outputs links
contained in an array:
</p>



<pre class="example">
$(MAP (link =&gt; links)
  &lt;a href="$link.address|html"
     title="$link.tooltip|html"&gt;$link.text|html&lt;/a&gt; $)
</pre>




<p>
That's assuming that <code>links</code> is an array of objects, each containing
<code>address</code>, <code>tooltip</code> and <code>text</code>.  You could also use a literal object (the
parser is smart enough for this):
</p>



<pre class="example">
$(MAP (link =&gt; [ { address : "http://www.google.com/",
                   tooltip : "Search engine",
                   text    : "Google" },

                 { address : "http://www.ymacs.org/",
                   tooltip : "AJAX code editor",
                   text    : "Ymacs" }
               ])
  &lt;a href="$link.address|html"
     title="$link.tooltip|html"&gt;$link.text|html&lt;/a&gt; $)
</pre>




<p>
Sometimes you also need to know the current step of the iteration.  For
example if you want to output some links that are separated with a pipe, you
need to know not to output the pipe before the first, or after the last
link.  We could write it like this:
</p>



<pre class="example">
$(MAP (i, link =&gt; links)
  $(WHEN (i &gt; 0) | $)
  &lt;a href="$link.address|html"
     title="$link.tooltip|html"&gt;$link.text|html&lt;/a&gt; $)
</pre>




<p>
or
</p>



<pre class="example">
$(MAP (i, link =&gt; links)
  ${ i &gt; 0 ? "|" : "" }
  &lt;a href="$link.address|html"
     title="$link.tooltip|html"&gt;$link.text|html&lt;/a&gt; $)
</pre>




<p>
A special case of <code>MAP</code> / <code>FOREACH</code> allows you to pass only the array, and
no key or index variables.  In this case the special variable <code>$_</code> (which I
will call the Perlism) gets assigned to the current element, and <i>more</i>, the
loop body is lexically scoped to each element using a JavaScript <code>with</code>
block (I know, your mom told you not to play the <code>with</code> statement, but mine
didn't<sup><a class="footref" name="fnr.3" href="#fn.3">3</a></sup> :-p).
</p>
<p>
So using this style the first example would become:
</p>



<pre class="example">
$(MAP (links)
  &lt;a href="$address|html" title="$tooltip|html"&gt;$text|html&lt;/a&gt; $)
</pre>




<p>
<code>address</code>, <code>tooltip</code> and <code>text</code> access the specific property of each
element.
</p>
<p>
Just a last example showing the Perlism:
</p>



<pre class="example">
$(FOREACH ([ "foo", "bar", "baz" ]) &lt;b&gt;$_&lt;/b&gt; $)
</pre>




<p>
will output “&lt;b&gt;foo&lt;/b&gt; &lt;b&gt;bar&lt;/b&gt; &lt;b&gt;baz&lt;/b&gt;”.  The <code>$_</code> variable is bound
to each element.
</p>
</div>

</div>

<div id="outline-container-5.3.4" class="outline-4">
<h4 id="sec-5.3.4">5.3.4 <code>MAPHASH</code> &mdash; iterate an object (hash) </h4>
<div id="text-5.3.4">


<p>
<code>MAPHASH</code> is <code>MAP</code>'s analogue for hashes.  It iterates over all properties
of an object, binding a variable for the key and another for the value.  You
must specify names for these variables.  Example, assuming that <code>users</code> is a
hash that maps user IDs to some user objects (each of them having a
<code>getName()</code> method):
</p>



<pre class="example">
$(MAPHASH (uid, obj =&gt; users)
  User &lt;b&gt;$uid&lt;/b&gt; has name &lt;b&gt;${ obj.getName() }&lt;/b&gt;&lt;br /&gt; $)
</pre>




</div>

</div>

<div id="outline-container-5.3.5" class="outline-4">
<h4 id="sec-5.3.5">5.3.5 <code>CONTINUE</code> and <code>BREAK</code> &mdash; for loop control </h4>
<div id="text-5.3.5">


<p>
These don't take any arguments, and also don't take a block of text, so the
expected syntax is <code>$(CONTINUE)</code> and <code>$(BREAK)</code>.  They can appear in the
text block of some looping construct, be it <code>REPEAT</code>, <code>LOOP</code>, <code>MAP</code>,
<code>FOREACH</code> or <code>MAPHASH</code>, and they do the same as their JavaScript
counterparts, that is: <code>CONTINUE</code> will go to the next iteration, skipping
any code between it and the end of the loop, and <code>BREAK</code> will immediately
end the loop.
</p>
<p>
I'm giving an example just to illustrate the syntax:
</p>



<pre class="example">
$(REPEAT (10 =&gt; i)
  $(WHEN (i &gt; 5) $(BREAK) $)
  $i
$)
</pre>




<p>
The above will print numbers from 1 to 5.
</p>
</div>

</div>

<div id="outline-container-5.3.6" class="outline-4">
<h4 id="sec-5.3.6">5.3.6 <code>LET</code> and <code>VAR</code> &mdash; define variables </h4>
<div id="text-5.3.6">


<p>
You can define new variables with <code>LET</code> and <code>VAR</code>.  They are not equivalent:
<code>LET</code> introduces a new lexical scope, so the variables that you define are
only available in its block of text.  <code>VAR</code> on the other hand does something
similar to the standard JavaScript <code>var</code> keyword.  Note that they are <i>still not global variables</i>&mdash;they are local to the innermost function that
contains the declaration, which in many cases is your template itself, but
could be a <a href="#sec-5.3.8"><code>BLOCK</code> or <code>FUNCTION</code></a> block too.
</p>
<p>
<code>VAR</code> does not accept a text argument, so it ends directly with a closing
paren (no need for <code>$)</code>).  Example:
</p>



<pre class="example">
$(VAR ((a =&gt; 10) (b =&gt; 20)))
$a + $b = ${ a + b }
</pre>




<p>
If variables with the same name were previously defined, they are replaced
with the new ones.
</p>
<p>
<code>LET</code> introduces variables that are local to its block.  If variables with
the same name already exist, they are shadowed while the <code>LET</code> block is
rendered.  After the <code>LET</code> block ends, previous values come back to life.
</p>



<pre class="example">
$(LET ((a =&gt; 10) (b =&gt; 20))
  $a + $b = ${ a + b }
$)
</pre>




<p>
Since <code>LET</code> takes a block of text, it ends with the normal block terminator
<code>$)</code>.  Here's an example to demonstrate scope:
</p>



<pre class="example">
$(VAR ((x =&gt; "outside")))
$(LET ((x =&gt; 10))
  $x is 10
  $(LET ((x =&gt; 20))
    $x is 20
  $)
  $x is back 10
$)
$x is "outside"
</pre>




<p>
<code>LET</code> operates by introducing an anonymous function, so it is compatible
with all browsers.  JavaScript 1.7 introduced a <code>let</code> statement for
declaring block-scoped variables, and it's supported by Firefox, but
unfortunately no other browser has it at the moment.
</p>
</div>

</div>

<div id="outline-container-5.3.7" class="outline-4">
<h4 id="sec-5.3.7">5.3.7 <code>WITH</code> &mdash; modify the scope chain </h4>
<div id="text-5.3.7">


<p>
When you have an object that has properties you need to access, you can use
a <code>WITH</code> block to make for a more convenient syntax, so instead of saying
<code>$object.foo</code> you would be able to say only <code>$foo</code>.  Assuming that <code>link</code>
contains <code>address</code>, <code>tooltip</code> and <code>text</code>, the following two are equivalent:
</p>



<pre class="example">
&lt;a href="$link.address|html" title="$link.tooltip|html"&gt;$link.text|html&lt;/a&gt;

$(WITH (link)
  &lt;a href="$address|html" title="$tooltip|html"&gt;$text|html&lt;/a&gt; $)
</pre>




<p>
<code>WITH</code> can be used with literal objects as well:
</p>



<pre class="example">
$(WITH ({ foo: 10, bar: 20 })
  $foo + $bar = ${ foo + bar }
$)
</pre>




<p>
thus emulating a <code>LET</code> block, but it's less efficient because it uses the
<a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Statements/with">JavaScript with statement</a>.
</p>
</div>

</div>

<div id="outline-container-5.3.8" class="outline-4">
<h4 id="sec-5.3.8">5.3.8 <code>BLOCK</code> and <code>FUNCTION</code> &mdash; define reusable template blocks </h4>
<div id="text-5.3.8">


<p>
Both of these constructs define a function (local to your template) which
renders a text block.  The difference between them is that <code>BLOCK</code> will
define a function that “prints” the text block into the template output (and
returns nothing), while <code>FUNCTION</code> will just return it.
</p>
<p>
The syntax is straightforward.  They expect a name for the function,
followed by a list of arguments in parens (if there are no arguments, put
<code>()</code> like you do for a plain JavaScript function).  Then continue with the
block of text that the function should expand into:
</p>



<pre class="example">
$(BLOCK display_link(link)
  &lt;a href="$link.address|html" title="$link.title|html"&gt;$link.text|html&lt;/a&gt;
$)

&lt;!-- call it literally --&gt;
$( display_link({ address: "/", title="Home page", text: "Home" }) )

&lt;!-- or call it for an object --&gt;
$(FOREACH (i IN links)
  $( display_link(i) )
$)
</pre>




<p>
As you see, using <code>BLOCK / FUNCTION</code> you can split your template into small
components.  Instead of having a big <code>FOREACH</code> loop that outputs a lot of
stuff, we can separate logical parts in blocks and then just call them, so
the loop itself becomes small.
</p>
<p>
Combining <code>BLOCK</code> and <code>LET</code> or <code>WITH</code> we can define closures:
</p>



<pre class="example">
$(WITH ({ value: 0 })
  $(BLOCK counter()
    &lt;p&gt;Counter is ${ ++value }&lt;/p&gt; $) $)

$( counter() ) -- now it's 1
$( counter() ) -- now it's 2
$( counter() ) -- now it's 3
</pre>




<p>
Doing the above with <code>LET</code> is a bit more tricky because <code>LET</code> creates its
own environment, so the <code>BLOCK</code> that you define within it is actually local
to the <code>LET</code> block.  The following won't work:
</p>



<pre class="example">
$(LET ((value =&gt; 0))
  $(BLOCK counter()
    &lt;p&gt;Counter is ${ ++value }&lt;/p&gt; $) $)

$( counter() ) -- error, counter is not defined!
</pre>




<p>
It's easy to see why if you see the code that gets generated for the above.
It looks like the following:
</p>



<pre class="example">
(function(){
    var value = 0;
    function counter() {
        output("Counter is " + (++value));
    };
})();

counter(); // but there's no free lunch
</pre>




<p>
To do this with a <code>LET</code> block we would have to export the function; we can
use an outside variable for that:
</p>



<pre class="example">
$(VAR (counter))
$(LET ((value =&gt; 0))
  $( counter = _counter /* export it */ )
  $(BLOCK _counter()
    &lt;p&gt;Counter is ${ ++value }&lt;/p&gt; $) $)

$( counter() ) -- now it works.
</pre>




</div>

</div>

<div id="outline-container-5.3.9" class="outline-4">
<h4 id="sec-5.3.9">5.3.9 <code>WRAP</code>, <code>CONTENT</code> &mdash; call a wrapper with an additional block of text </h4>
<div id="text-5.3.9">


<p>
<code>BLOCK</code> can be used to define wrappers.  A wrapper is a function that
receives a bit of text and puts something before and after it.  For example,
to define a wrapper that creates a table we can say:
</p>



<pre class="example">
&lt;!-- define our wrapper --&gt;
$(BLOCK table(cols)
  &lt;table&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        $(MAP (label =&gt; cols) &lt;td&gt;$label&lt;/td&gt; $)
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      $(CONTENT)
    &lt;/tbody&gt;
  &lt;/table&gt; $)

&lt;!-- and here's how we use it --&gt;
$(WRAP table([ "Name", "Phone", "Email" ])
  &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;td&gt;123-1234&lt;/td&gt; &lt;td&gt;foo@foo.com&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Bar&lt;/td&gt; &lt;td&gt;1234-123&lt;/td&gt; &lt;td&gt;bar@bar.com&lt;/td&gt; &lt;/tr&gt;
$)
</pre>




<p>
You can note that a wrapper is a normal function defined with <code>BLOCK</code> or
<code>FUNCTION</code>, and it can take arguments.  To send the arguments with a <code>WRAP</code>
block, just make it look like a normal function call.  If there are no
arguments, you still need to insert the parens <code>()</code>.  When it's calling your
block, <code>WRAP</code> sends an additional hidden argument that contains the text
which is expanded by <code>$(CONTENT)</code>.  For now this argument is a function that
renders the text, and <code>$(CONTENT)</code> simply calls this function.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><a name="Correctness" id="Correctness"></a>6 Correctness </h2>
<div id="text-6">


<p>
YAJET aims to do The Right Thing.  If you've ever written Lisp or C macros,
then you know that it's dangerous to invent variable names, or to use a
macro argument more than once.  YAJET is essentially a macro expander and
it's built around good principles.
</p>
<p>
For example, a dumb implementation would translate <code>$(FOREACH (link =&gt; links) ...STUFF... $)</code> into this:
</p>



<pre class="example">
for (var i = 0; i &lt; links.length; ++i) {
    var link = links[i];
    ... do STUFF
}
</pre>




<p>
However the above code has two problems:
</p>
<ol>
<li>
if the text in <code>STUFF</code> defines a variable named <code>i</code>, then it will collide
with the loop variable.

</li>
<li>
if <code>links</code> is not a real array, but say, a (possibly expensive, and
perhaps with weird side effects) function call that returns an array,
then it will be evaluated for each iteration&hellip; twice.

</li>
</ol>

<p>If <code>FOREACH</code> would really expand into the above code, then the following
sample would suffer from both problems:
</p>



<pre class="example">
$(FOREACH (link =&gt; this.getLinksFromServer())
  $(VAR ((i =&gt; link.text.length)))
  $(WHEN (i &gt; 30)
    ... truncate text
  $)
  ...
$)
</pre>




<p>
The resulted code would be:
</p>



<pre class="example">
for (var i = 0; i &lt; this.getLinksFromServer().length; ++i) {
    var link = this.getLinksFromServer()[i];
    var i = link.text.length;
    if (i &gt; 30) {
        ... truncate text
    }
    ...
}
</pre>




<p>
&hellip; which means that this.getLinksFromServer() will be called twice for each
step, and also that the loop would be stopped arbitrarily when we encounter
a link whose text has more characters than the number of links.  That would
break in unexpected and hard to debug ways.
</p>
<p>
YAJET avoids this problem by creating temporary variables with (hopefully)
unique names, so that template writes don't have to worry about it.  The
actual generated code is more like this:
</p>



<pre class="example">
var __GSY12 = this.getLinksFromServer();
for (var __GSY13 = 0; __GSY13 &lt; __GSY12.length; ++__GSY13) {
    var link = __GSY12[__GSY13];
    var i = link.text.length;
    if (i &gt; 30) {
        ... truncate text
    }
    ...
}
</pre>




<p>
The variables that are created get the prefix <code>__GSY</code> and a number which is
unique per compilation, so you should be safe as long as you don't use the
<code>__GSY</code> prefix yourself.  Hope you don't. :-)
</p>







</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">7 Known issues </h2>
<div id="text-7">



</div>

<div id="outline-container-7.1" class="outline-3">
<h3 id="sec-7.1">7.1 Literal RegExp-s in JavaScript expressions </h3>
<div id="text-7.1">


<p>
The JavaScript parser is not “complete”, although it's smart enough to skip
comments and strings while looking for a closing paren.  Literal regexps are
always tricky to parse, so I left this out for now, but I do plan to fix it.
However, what this means for now is that you should be careful about parens
in literal RegExp-s.  Since the parser does not allow for unbalanced parens,
the following should <i>not</i> be a problem:
</p>



<pre class="example">
$( if (/(a|b)/.test("bar")) {
     matches();
   } else {
     no_match();
   }
 )
</pre>




<p>
All parens are properly closed, so there's no reason why our parser should
miss the closing paren.  However, the following will break stuff:
</p>



<pre class="example">
$( if (/\)/.test(")")) { ... } )
</pre>




<p>
Although it is valid JavaScript inside, having the closing paren in the
RegExp will confuse YAJET.  It looks quite ugly, too&mdash;for such cases,
encode the paren as <code>\x29</code>.  Note that you have to escape open parens as
well (<code>\x28</code>), and same goes for all the other types of brackets such as
<code>[</code>, <code>]</code>,  <code>{</code> and <code>}</code>.
</p>
</div>

</div>

<div id="outline-container-7.2" class="outline-3">
<h3 id="sec-7.2">7.2 Error reporting is less than ideal </h3>
<div id="text-7.2">


</div>

</div>

<div id="outline-container-7.3" class="outline-3">
<h3 id="sec-7.3">7.3 Whitespace handling </h3>
<div id="text-7.3">





</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">8 License </h2>
<div id="text-8">


<p>
Copyright (c) 2010, Mihai Bazon &lt;mihai.bazon@gmail.com&gt;.  All rights
reserved.
</p>
<p>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
</p>
<ul>
<li>
Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

</li>
<li>
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

</li>
</ul>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</p>









</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> The misspelling is intentional.  Various combinations of the
letters Y, A, J, T, E from “Yet Another JavaScript Template Engine” led to
the name YAJET.  YAJET stands for “Yet Another JavaScript Emplate Tengine”.
Sounds buzzy, isn't it?  Also, <a href="http://en.wikipedia.org/wiki/Jet_engine">JET</a>-s are fast, and so is YAJET.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> Although the directives that YAJET supports should provide
enough abstraction so that you don't need to pass on literal JS too often.
</p>
<p class="footnote"><sup><a class="footnum" name="fn.3" href="#fnr.3">3</a></sup> Seriously though, everything under an <code>with</code> block is
s&hellip;l&hellip;o&hellip;w&hellip; &ndash; so, while this makes for a nice syntax, you should not
use it where speed is critical.
</p>
</div>
</div>
<div id="postamble"><p class="author"> Author: Mihai Bazon
<a href="mailto:mihai.bazon@gmail.com">&lt;mihai.bazon@gmail.com&gt;</a>
</p>
<p class="date"> Date: 2010-05-01 12:31:16 CEST</p>
<p>HTML generated by org-mode 6.21b in emacs 23</p>
</div></body>
</html>
